//! Async vector optimization operations coordination facade
//!
//! This module provides a coordination facade for async vector optimization operations,
//! delegating to specialized submodules for blazing-fast performance with zero allocation
//! optimizations and elegant ergonomic interfaces.

mod search_strategies;
mod optimization_algorithms;

use smallvec::SmallVec;
use std::sync::Arc;
use std::time::Instant;
use tokio::sync::RwLock;
use tracing::{debug, info, warn};

use crate::memory::filter::MemoryFilter;
use crate::utils::error::Error;
use super::{VectorSearchResult, VectorStore};
use super::async_vector_operations::DistanceMetric;

// Re-export types from submodules
pub use search_strategies::{
    SearchStrategy, SearchStrategyExecutor, SearchMetrics, OptimizationParameters as SearchOptimizationParameters
};
pub use optimization_algorithms::{
    OptimizationAlgorithm, OptimizationExecutor, OptimizationMetrics, OptimizationConfig,
    DimensionReductionResult, QuantizationResult, IndexOptimizationResult,
    CacheOptimizationResult, BatchOptimizationResult, MemoryLayoutResult
};

/// Async vector optimization coordinator with zero allocation optimizations
pub struct AsyncVectorOptimizer {
    /// Search strategy executor
    search_executor: Arc<RwLock<SearchStrategyExecutor>>,
    /// Optimization algorithm executor
    optimization_executor: Arc<RwLock<OptimizationExecutor>>,
    /// Performance metrics
    metrics: CoordinationMetrics,
    /// Configuration
    config: OptimizerConfig,
}

impl AsyncVectorOptimizer {
    /// Create new async vector optimizer
    #[inline]
    pub fn new() -> Self {
        Self {
            search_executor: Arc::new(RwLock::new(SearchStrategyExecutor::new(SearchStrategy::BruteForce))),
            optimization_executor: Arc::new(RwLock::new(OptimizationExecutor::new())),
            metrics: CoordinationMetrics::new(),
            config: OptimizerConfig::default(),
        }
    }

    /// Create optimizer with specific configuration
    #[inline]
    pub fn with_config(config: OptimizerConfig) -> Self {
        let mut optimizer = Self::new();
        optimizer.config = config;
        optimizer
    }

    /// Execute optimized vector search with automatic strategy selection
    #[inline]
    pub async fn execute_optimized_search(
        &self,
        query_vector: &[f32],
        vectors: &[(String, Vec<f32>)],
        limit: usize,
        filter: Option<&MemoryFilter>,
        distance_metric: DistanceMetric,
    ) -> Result<SmallVec<[VectorSearchResult; 16]>, Error> {
        let start_time = Instant::now();
        
        debug!("Executing optimized vector search for {} vectors", vectors.len());

        // Determine optimal search strategy
        let optimal_strategy = SearchStrategy::determine_optimal(
            vectors.len(),
            limit,
            filter.is_some(),
            query_vector.len(),
        );

        debug!("Selected search strategy: {:?}", optimal_strategy);

        // Update search executor strategy if needed
        {
            let mut executor = self.search_executor.write().await;
            *executor = SearchStrategyExecutor::new(optimal_strategy);
        }

        // Execute search with selected strategy
        let results = match optimal_strategy {
            SearchStrategy::BruteForce => {
                let executor = self.search_executor.read().await;
                executor.execute_brute_force_search(
                    query_vector,
                    vectors,
                    limit,
                    filter,
                    distance_metric,
                ).await?
            }
            SearchStrategy::FilteredSearch => {
                if let Some(filter) = filter {
                    let executor = self.search_executor.read().await;
                    executor.execute_filtered_search(
                        query_vector,
                        vectors,
                        limit,
                        filter,
                        distance_metric,
                    ).await?
                } else {
                    // Fallback to brute force if no filter provided
                    let executor = self.search_executor.read().await;
                    executor.execute_brute_force_search(
                        query_vector,
                        vectors,
                        limit,
                        filter,
                        distance_metric,
                    ).await?
                }
            }
            _ => {
                // For other strategies, fallback to brute force for now
                let executor = self.search_executor.read().await;
                executor.execute_brute_force_search(
                    query_vector,
                    vectors,
                    limit,
                    filter,
                    distance_metric,
                ).await?
            }
        };

        let execution_time = start_time.elapsed();
        self.metrics.record_search_operation(execution_time, results.len());

        info!("Optimized search completed: {} results in {:?}", results.len(), execution_time);
        Ok(results)
    }

    /// Execute comprehensive vector optimization pipeline
    #[inline]
    pub async fn execute_optimization_pipeline(
        &self,
        vectors: &mut [(String, Vec<f32>)],
        optimization_spec: OptimizationSpec,
    ) -> Result<OptimizationPipelineResult, Error> {
        let start_time = Instant::now();
        
        info!("Executing optimization pipeline with {} algorithms", optimization_spec.algorithms.len());

        let mut pipeline_results = OptimizationPipelineResult::new();
        let mut executor = self.optimization_executor.write().await;

        // Execute each optimization algorithm in sequence
        for &algorithm in &optimization_spec.algorithms {
            match algorithm {
                OptimizationAlgorithm::DimensionReduction => {
                    if let Some(target_dims) = optimization_spec.dimension_reduction_target {
                        let result = executor.execute_dimension_reduction(vectors, target_dims).await?;
                        pipeline_results.dimension_reduction = Some(result);
                    }
                }
                OptimizationAlgorithm::VectorQuantization => {
                    let levels = optimization_spec.quantization_levels.unwrap_or(256);
                    let result = executor.execute_vector_quantization(vectors, levels).await?;
                    pipeline_results.quantization = Some(result);
                }
                OptimizationAlgorithm::IndexOptimization => {
                    let result = executor.execute_index_optimization(vectors).await?;
                    pipeline_results.index_optimization = Some(result);
                }
                OptimizationAlgorithm::CacheOptimization => {
                    let cache_size = optimization_spec.cache_size.unwrap_or(1000);
                    let result = executor.execute_cache_optimization(vectors, cache_size).await?;
                    pipeline_results.cache_optimization = Some(result);
                }
                OptimizationAlgorithm::BatchOptimization => {
                    let batch_size = optimization_spec.batch_size.unwrap_or(64);
                    let result = executor.execute_batch_optimization(vectors, batch_size).await?;
                    pipeline_results.batch_optimization = Some(result);
                }
                OptimizationAlgorithm::MemoryLayoutOptimization => {
                    let result = executor.execute_memory_layout_optimization(vectors).await?;
                    pipeline_results.memory_layout = Some(result);
                }
            }
        }

        let total_execution_time = start_time.elapsed();
        pipeline_results.total_execution_time = total_execution_time;

        self.metrics.record_optimization_pipeline(
            total_execution_time,
            optimization_spec.algorithms.len(),
        );

        info!("Optimization pipeline completed: {} algorithms in {:?}", 
              optimization_spec.algorithms.len(), total_execution_time);

        Ok(pipeline_results)
    }

    /// Execute adaptive optimization based on vector characteristics
    #[inline]
    pub async fn execute_adaptive_optimization(
        &self,
        vectors: &mut [(String, Vec<f32>)],
    ) -> Result<OptimizationPipelineResult, Error> {
        let start_time = Instant::now();
        
        debug!("Analyzing vector characteristics for adaptive optimization");

        // Analyze vector characteristics
        let characteristics = self.analyze_vector_characteristics(vectors).await?;
        
        // Generate optimization recommendations
        let recommendations = self.generate_optimization_recommendations(&characteristics).await?;
        
        // Create optimization specification from recommendations
        let optimization_spec = OptimizationSpec::from_recommendations(&recommendations);
        
        // Execute optimization pipeline
        let result = self.execute_optimization_pipeline(vectors, optimization_spec).await?;

        let total_time = start_time.elapsed();
        info!("Adaptive optimization completed in {:?}", total_time);

        Ok(result)
    }

    /// Get comprehensive performance metrics
    #[inline]
    pub async fn get_performance_metrics(&self) -> PerformanceMetrics {
        let search_metrics = {
            let executor = self.search_executor.read().await;
            executor.get_metrics().clone()
        };

        let optimization_metrics = {
            let executor = self.optimization_executor.read().await;
            executor.get_metrics().clone()
        };

        PerformanceMetrics {
            search_metrics,
            optimization_metrics,
            coordination_metrics: self.metrics.clone(),
        }
    }

    /// Update optimizer configuration
    #[inline]
    pub fn update_config(&mut self, config: OptimizerConfig) {
        self.config = config;
    }

    /// Get current configuration
    #[inline]
    pub fn get_config(&self) -> &OptimizerConfig {
        &self.config
    }

    /// Helper methods for adaptive optimization
    #[inline]
    async fn analyze_vector_characteristics(
        &self,
        vectors: &[(String, Vec<f32>)],
    ) -> Result<VectorCharacteristics, Error> {
        if vectors.is_empty() {
            return Ok(VectorCharacteristics::default());
        }

        let vector_count = vectors.len();
        let dimensions = vectors[0].1.len();
        
        // Calculate basic statistics
        let mut total_magnitude = 0.0f64;
        let mut min_magnitude = f64::INFINITY;
        let mut max_magnitude = 0.0f64;
        
        for (_, vector) in vectors {
            let magnitude: f64 = vector.iter().map(|&x| (x as f64).powi(2)).sum::<f64>().sqrt();
            total_magnitude += magnitude;
            min_magnitude = min_magnitude.min(magnitude);
            max_magnitude = max_magnitude.max(magnitude);
        }

        let average_magnitude = total_magnitude / vector_count as f64;
        let magnitude_variance = max_magnitude - min_magnitude;

        // Estimate sparsity
        let mut zero_count = 0;
        let mut total_elements = 0;
        
        for (_, vector) in vectors.iter().take(100.min(vectors.len())) {
            for &value in vector {
                if value.abs() < 1e-6 {
                    zero_count += 1;
                }
                total_elements += 1;
            }
        }

        let sparsity = zero_count as f64 / total_elements as f64;

        Ok(VectorCharacteristics {
            vector_count,
            dimensions,
            average_magnitude,
            magnitude_variance,
            sparsity,
            estimated_memory_mb: (vector_count * dimensions * 4) / (1024 * 1024),
        })
    }

    /// Generate optimization recommendations based on characteristics
    #[inline]
    async fn generate_optimization_recommendations(
        &self,
        characteristics: &VectorCharacteristics,
    ) -> Result<SmallVec<[OptimizationRecommendation; 8]>, Error> {
        let mut recommendations = SmallVec::new();

        // Dimension reduction for high-dimensional vectors
        if characteristics.dimensions > 512 {
            recommendations.push(OptimizationRecommendation {
                algorithm: OptimizationAlgorithm::DimensionReduction,
                priority: 0.8,
                expected_improvement: 0.4,
                parameters: OptimizationParameters {
                    dimension_reduction_target: Some(characteristics.dimensions / 2),
                    ..Default::default()
                },
            });
        }

        // Vector quantization for large datasets
        if characteristics.vector_count > 10000 {
            recommendations.push(OptimizationRecommendation {
                algorithm: OptimizationAlgorithm::VectorQuantization,
                priority: 0.7,
                expected_improvement: 0.6,
                parameters: OptimizationParameters {
                    quantization_levels: Some(256),
                    ..Default::default()
                },
            });
        }

        // Index optimization for large datasets
        if characteristics.vector_count > 1000 {
            recommendations.push(OptimizationRecommendation {
                algorithm: OptimizationAlgorithm::IndexOptimization,
                priority: 0.9,
                expected_improvement: 0.8,
                parameters: OptimizationParameters::default(),
            });
        }

        // Cache optimization for frequent access patterns
        if characteristics.vector_count > 100 {
            recommendations.push(OptimizationRecommendation {
                algorithm: OptimizationAlgorithm::CacheOptimization,
                priority: 0.6,
                expected_improvement: 0.3,
                parameters: OptimizationParameters {
                    cache_size: Some(characteristics.vector_count.min(1000)),
                    ..Default::default()
                },
            });
        }

        // Memory layout optimization for large memory usage
        if characteristics.estimated_memory_mb > 100 {
            recommendations.push(OptimizationRecommendation {
                algorithm: OptimizationAlgorithm::MemoryLayoutOptimization,
                priority: 0.5,
                expected_improvement: 0.2,
                parameters: OptimizationParameters::default(),
            });
        }

        // Sort by priority
        recommendations.sort_by(|a, b| b.priority.partial_cmp(&a.priority).unwrap());

        Ok(recommendations)
    }
}

impl Default for AsyncVectorOptimizer {
    fn default() -> Self {
        Self::new()
    }
}

/// Supporting types for coordination
#[derive(Debug, Clone)]
pub struct OptimizationSpec {
    pub algorithms: SmallVec<[OptimizationAlgorithm; 8]>,
    pub dimension_reduction_target: Option<usize>,
    pub quantization_levels: Option<usize>,
    pub cache_size: Option<usize>,
    pub batch_size: Option<usize>,
}

impl OptimizationSpec {
    pub fn new() -> Self {
        Self {
            algorithms: SmallVec::new(),
            dimension_reduction_target: None,
            quantization_levels: None,
            cache_size: None,
            batch_size: None,
        }
    }

    pub fn from_recommendations(recommendations: &[OptimizationRecommendation]) -> Self {
        let mut spec = Self::new();
        
        for recommendation in recommendations {
            spec.algorithms.push(recommendation.algorithm);
            
            match recommendation.algorithm {
                OptimizationAlgorithm::DimensionReduction => {
                    spec.dimension_reduction_target = recommendation.parameters.dimension_reduction_target;
                }
                OptimizationAlgorithm::VectorQuantization => {
                    spec.quantization_levels = recommendation.parameters.quantization_levels;
                }
                OptimizationAlgorithm::CacheOptimization => {
                    spec.cache_size = recommendation.parameters.cache_size;
                }
                OptimizationAlgorithm::BatchOptimization => {
                    spec.batch_size = recommendation.parameters.batch_size;
                }
                _ => {}
            }
        }
        
        spec
    }
}

impl Default for OptimizationSpec {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct OptimizationPipelineResult {
    pub dimension_reduction: Option<DimensionReductionResult>,
    pub quantization: Option<QuantizationResult>,
    pub index_optimization: Option<IndexOptimizationResult>,
    pub cache_optimization: Option<CacheOptimizationResult>,
    pub batch_optimization: Option<BatchOptimizationResult>,
    pub memory_layout: Option<MemoryLayoutResult>,
    pub total_execution_time: std::time::Duration,
}

impl OptimizationPipelineResult {
    pub fn new() -> Self {
        Self {
            dimension_reduction: None,
            quantization: None,
            index_optimization: None,
            cache_optimization: None,
            batch_optimization: None,
            memory_layout: None,
            total_execution_time: std::time::Duration::from_secs(0),
        }
    }
}

impl Default for OptimizationPipelineResult {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct VectorCharacteristics {
    pub vector_count: usize,
    pub dimensions: usize,
    pub average_magnitude: f64,
    pub magnitude_variance: f64,
    pub sparsity: f64,
    pub estimated_memory_mb: usize,
}

impl Default for VectorCharacteristics {
    fn default() -> Self {
        Self {
            vector_count: 0,
            dimensions: 0,
            average_magnitude: 0.0,
            magnitude_variance: 0.0,
            sparsity: 0.0,
            estimated_memory_mb: 0,
        }
    }
}

#[derive(Debug, Clone)]
pub struct OptimizationRecommendation {
    pub algorithm: OptimizationAlgorithm,
    pub priority: f64,
    pub expected_improvement: f64,
    pub parameters: OptimizationParameters,
}

#[derive(Debug, Clone)]
pub struct OptimizationParameters {
    pub dimension_reduction_target: Option<usize>,
    pub quantization_levels: Option<usize>,
    pub cache_size: Option<usize>,
    pub batch_size: Option<usize>,
}

impl Default for OptimizationParameters {
    fn default() -> Self {
        Self {
            dimension_reduction_target: None,
            quantization_levels: None,
            cache_size: None,
            batch_size: None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct CoordinationMetrics {
    pub total_search_operations: std::sync::atomic::AtomicUsize,
    pub total_optimization_pipelines: std::sync::atomic::AtomicUsize,
    pub total_coordination_time_ms: std::sync::atomic::AtomicUsize,
}

impl CoordinationMetrics {
    pub fn new() -> Self {
        Self {
            total_search_operations: std::sync::atomic::AtomicUsize::new(0),
            total_optimization_pipelines: std::sync::atomic::AtomicUsize::new(0),
            total_coordination_time_ms: std::sync::atomic::AtomicUsize::new(0),
        }
    }

    pub fn record_search_operation(&self, execution_time: std::time::Duration, _result_count: usize) {
        self.total_search_operations.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        self.total_coordination_time_ms.fetch_add(
            execution_time.as_millis() as usize,
            std::sync::atomic::Ordering::Relaxed,
        );
    }

    pub fn record_optimization_pipeline(&self, execution_time: std::time::Duration, _algorithm_count: usize) {
        self.total_optimization_pipelines.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        self.total_coordination_time_ms.fetch_add(
            execution_time.as_millis() as usize,
            std::sync::atomic::Ordering::Relaxed,
        );
    }
}

impl Default for CoordinationMetrics {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct OptimizerConfig {
    pub enable_adaptive_optimization: bool,
    pub max_concurrent_operations: usize,
    pub default_search_strategy: SearchStrategy,
    pub optimization_timeout_secs: u64,
}

impl Default for OptimizerConfig {
    fn default() -> Self {
        Self {
            enable_adaptive_optimization: true,
            max_concurrent_operations: 4,
            default_search_strategy: SearchStrategy::BruteForce,
            optimization_timeout_secs: 300,
        }
    }
}

#[derive(Debug, Clone)]
pub struct PerformanceMetrics {
    pub search_metrics: SearchMetrics,
    pub optimization_metrics: OptimizationMetrics,
    pub coordination_metrics: CoordinationMetrics,
}