//! Committee evaluation coordination
//!
//! This module coordinates all evaluation components and provides
//! the main Committee evaluation interface with blazing-fast performance.

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock};
use tracing::info;

use crate::cognitive::mcts::CodeState;
use crate::cognitive::types::{CognitiveError, OptimizationSpec};

use super::core::{AgentEvaluation, CommitteeAgent, CommitteeEvent, ConsensusDecision, EvaluationRubric};
use super::consensus::evaluation_phases::EvaluationPhase;

// Import all evaluation components
pub use self::evaluation::{
    ConsensusCalculator, AdvancedConsensusMetrics, EvaluationExecutor, 
    AgentSimulator, ExtendedCommitteeEvent, EvaluationStatistics, CommitteeBuilder
};

mod evaluation;

/// Main committee structure for consensus-based evaluation
pub struct Committee {
    pub agents: Vec<CommitteeAgent>,
    pub consensus_threshold: f64,
    pub max_concurrent: usize,
    pub cache: Arc<RwLock<HashMap<String, ConsensusDecision>>>,
    executor: EvaluationExecutor,
    consensus_calculator: ConsensusCalculator,
}

impl Committee {
    /// Create new committee with optimized configuration
    pub fn new(
        agents: Vec<CommitteeAgent>,
        consensus_threshold: f64,
        max_concurrent: usize,
        event_tx: mpsc::UnboundedSender<CommitteeEvent>,
    ) -> Self {
        let executor = EvaluationExecutor::new(max_concurrent, event_tx.clone());
        let consensus_calculator = ConsensusCalculator::new(consensus_threshold);
        
        Self {
            agents,
            consensus_threshold,
            max_concurrent,
            cache: Arc::new(RwLock::new(HashMap::new())),
            executor,
            consensus_calculator,
        }
    }

    /// Main evaluation entry point with caching and consensus calculation
    pub async fn evaluate_action(
        &self,
        state: &CodeState,
        action: &str,
        spec: &OptimizationSpec,
        user_objective: &str,
    ) -> Result<ConsensusDecision, CognitiveError> {
        // Check cache first for blazing-fast repeated evaluations
        let cache_key = format!("{}:{}:{}", action, spec.context.objective, user_objective);
        
        {
            let cache = self.cache.read().await;
            if let Some(cached_decision) = cache.get(&cache_key) {
                info!("Cache hit for action evaluation: {}", action);
                return Ok(cached_decision.clone());
            }
        }

        info!("Starting committee evaluation for action: {}", action);

        // Create evaluation rubric
        let rubric = EvaluationRubric {
            code_quality_weight: 0.3,
            functionality_weight: 0.4,
            alignment_weight: 0.3,
            user_objective: user_objective.to_string(),
            optimization_spec: spec.clone(),
        };

        // Get agent IDs for evaluation
        let agent_ids: Vec<String> = self.agents.iter().map(|a| a.id.clone()).collect();

        // Execute parallel evaluation using the executor
        let evaluations = self.executor.run_extended_evaluation_phase(
            &agent_ids,
            state,
            action,
            &rubric,
            EvaluationPhase::Initial,
            None,
            None,
        ).await?;

        // Calculate consensus using the consensus calculator
        let decision = self.consensus_calculator.calculate_consensus(&evaluations)?;

        // Cache the result for future use
        {
            let mut cache = self.cache.write().await;
            cache.insert(cache_key, decision.clone());
        }

        info!("Committee evaluation completed with {} evaluations", evaluations.len());
        Ok(decision)
    }
}