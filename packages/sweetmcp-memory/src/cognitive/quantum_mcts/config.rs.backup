//! Quantum MCTS configuration with compile-time optimization and zero-copy serialization
//!
//! This module provides blazing-fast configuration management with environment variable
//! overrides and validation for optimal quantum MCTS performance.

// Re-export all configuration functionality from submodules
pub use self::{
    core::QuantumMCTSConfig,
    builder::{
        QuantumMCTSConfigBuilder, FluentConfigBuilder, ConfigPreset,
        ParallelismConfig, ThresholdConfig, PerformanceConfig, AccuracyConfig,
    },
    validation::{ConfigValidator, ValidationError},
    system::{
        SystemAnalyzer, SystemResources, SystemCapabilitySummary,
        ArchType, PerformanceTier, ConfigType,
    },
    environment::{EnvironmentLoader, ConfigSource, EnvironmentError},
};

// Submodule declarations
mod core;
mod builder;
mod validation;
mod system;
mod environment;

/// Configuration coordinator for centralized management
pub struct ConfigCoordinator {
    analyzer: SystemAnalyzer,
    env_loader: EnvironmentLoader,
}

impl ConfigCoordinator {
    /// Create new configuration coordinator
    pub fn new() -> Self {
        Self {
            analyzer: SystemAnalyzer::new(),
            env_loader: EnvironmentLoader::new(),
        }
    }

    /// Create optimal configuration for current system
    pub fn create_optimal_config(&self) -> QuantumMCTSConfig {
        let mut config = self.analyzer.system_optimized_config();
        
        // Apply environment overrides
        if let Ok(env_config) = self.env_loader.load_from_environment() {
            config = self.merge_configs(config, env_config);
        }
        
        // Validate final configuration
        if let Err(e) = ConfigValidator::validate(&config) {
            eprintln!("Warning: Configuration validation failed: {}. Using system defaults.", e);
            config = self.analyzer.system_optimized_config();
        }
        
        config
    }

    /// Create configuration from preset with system optimization
    pub fn create_from_preset(&self, preset: ConfigPreset) -> QuantumMCTSConfig {
        match FluentConfigBuilder::preset(preset).build() {
            Ok(config) => {
                // Verify system compatibility
                if let Err(e) = self.analyzer.is_compatible(&config) {
                    eprintln!("Warning: Preset incompatible with system: {}. Using optimized config.", e);
                    self.analyzer.system_optimized_config()
                } else {
                    config
                }
            },
            Err(e) => {
                eprintln!("Warning: Preset configuration invalid: {}. Using system defaults.", e);
                self.analyzer.system_optimized_config()
            }
        }
    }

    /// Validate configuration against current system
    pub fn validate_config(&self, config: &QuantumMCTSConfig) -> Result<(), String> {
        // First validate parameter bounds
        ConfigValidator::validate(config)?;
        
        // Then check system compatibility
        self.analyzer.is_compatible(config)?;
        
        Ok(())
    }

    /// Merge two configurations with intelligent precedence
    fn merge_configs(&self, base: QuantumMCTSConfig, override_config: QuantumMCTSConfig) -> QuantumMCTSConfig {
        // Environment variables override system-optimized values
        // but only if they pass validation
        let mut merged = base;
        
        // Merge parallelism (with bounds checking)
        if override_config.max_quantum_parallel != base.max_quantum_parallel {
            let cpu_count = self.analyzer.resources().cpu_count;
            if override_config.max_quantum_parallel <= cpu_count * 4 {
                merged.max_quantum_parallel = override_config.max_quantum_parallel;
            }
        }
        
        // Merge other parameters with validation
        if (0.1..=10.0).contains(&override_config.quantum_exploration) {
            merged.quantum_exploration = override_config.quantum_exploration;
        }
        
        if (0.001..=1.0).contains(&override_config.decoherence_threshold) {
            merged.decoherence_threshold = override_config.decoherence_threshold;
        }
        
        if (0.0..=1.0).contains(&override_config.entanglement_strength) {
            merged.entanglement_strength = override_config.entanglement_strength;
        }
        
        if override_config.recursive_iterations > 0 && override_config.recursive_iterations <= 20 {
            merged.recursive_iterations = override_config.recursive_iterations;
        }
        
        if (0.0001..=1.0).contains(&override_config.amplitude_threshold) {
            merged.amplitude_threshold = override_config.amplitude_threshold;
        }
        
        if (0.001..=1.0).contains(&override_config.phase_evolution_rate) {
            merged.phase_evolution_rate = override_config.phase_evolution_rate;
        }
        
        if override_config.simulation_timeout_ms >= 100 && override_config.simulation_timeout_ms <= 3_600_000 {
            merged.simulation_timeout_ms = override_config.simulation_timeout_ms;
        }
        
        if override_config.max_tree_size >= 10 && override_config.max_tree_size <= 10_000_000 {
            merged.max_tree_size = override_config.max_tree_size;
        }
        
        // Boolean flags are merged directly
        merged.enable_error_correction = override_config.enable_error_correction;
        
        if override_config.measurement_precision > 0.0 && override_config.measurement_precision <= 1.0 {
            merged.measurement_precision = override_config.measurement_precision;
        }
        
        merged
    }

    /// Create configuration for specific use case
    pub fn create_for_use_case(&self, use_case: UseCase) -> QuantumMCTSConfig {
        let config = match use_case {
            UseCase::RealTime => {
                FluentConfigBuilder::preset(ConfigPreset::Performance)
                    .performance().speed()
                    .parallelism().conservative()
                    .build_unchecked()
            },
            UseCase::BatchProcessing => {
                FluentConfigBuilder::preset(ConfigPreset::Accuracy)
                    .accuracy().maximum()
                    .parallelism().aggressive()
                    .build_unchecked()
            },
            UseCase::Mobile => {
                FluentConfigBuilder::preset(ConfigPreset::Minimal)
                    .performance().speed()
                    .parallelism().custom(1)
                    .build_unchecked()
            },
            UseCase::HighPerformanceComputing => {
                FluentConfigBuilder::preset(ConfigPreset::Accuracy)
                    .accuracy().maximum()
                    .parallelism().aggressive()
                    .build_unchecked()
            },
            UseCase::Development => {
                FluentConfigBuilder::preset(ConfigPreset::Default)
                    .performance().balanced()
                    .parallelism().cpu_count()
                    .build_unchecked()
            },
            UseCase::Testing => {
                FluentConfigBuilder::preset(ConfigPreset::Minimal)
                    .performance().speed()
                    .parallelism().custom(1)
                    .transform(|mut c| {
                        c.simulation_timeout_ms = 1_000; // Very short for tests
                        c.max_tree_size = 100; // Tiny tree for tests
                        c
                    })
                    .build_unchecked()
            },
        };
        
        // Validate against system
        if let Err(e) = self.validate_config(&config) {
            eprintln!("Warning: Use case config incompatible: {}. Using system defaults.", e);
            self.analyzer.system_optimized_config()
        } else {
            config
        }
    }
}

impl Default for ConfigCoordinator {
    fn default() -> Self {
        Self::new()
    }
}

/// Common use cases for configuration optimization
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UseCase {
    RealTime,
    BatchProcessing,
    Mobile,
    HighPerformanceComputing,
    Development,
    Testing,
}

/// Configuration factory functions for common scenarios
pub mod factory {
    use super::*;
    use std::sync::OnceLock;

    static COORDINATOR: OnceLock<ConfigCoordinator> = OnceLock::new();

    fn coordinator() -> &'static ConfigCoordinator {
        COORDINATOR.get_or_init(ConfigCoordinator::new)
    }

    /// Create default configuration with system optimization
    pub fn default() -> QuantumMCTSConfig {
        coordinator().create_optimal_config()
    }

    /// Create performance-optimized configuration
    pub fn performance() -> QuantumMCTSConfig {
        coordinator().create_from_preset(ConfigPreset::Performance)
    }

    /// Create accuracy-optimized configuration  
    pub fn accuracy() -> QuantumMCTSConfig {
        coordinator().create_from_preset(ConfigPreset::Accuracy)
    }

    /// Create system-optimized configuration
    pub fn system_optimized() -> QuantumMCTSConfig {
        coordinator().create_from_preset(ConfigPreset::SystemOptimized)
    }

    /// Create minimal configuration for constrained environments
    pub fn minimal() -> QuantumMCTSConfig {
        coordinator().create_from_preset(ConfigPreset::Minimal)
    }

    /// Create configuration for real-time applications
    pub fn real_time() -> QuantumMCTSConfig {
        coordinator().create_for_use_case(UseCase::RealTime)
    }

    /// Create configuration for batch processing
    pub fn batch_processing() -> QuantumMCTSConfig {
        coordinator().create_for_use_case(UseCase::BatchProcessing)
    }

    /// Create configuration for mobile/embedded systems
    pub fn mobile() -> QuantumMCTSConfig {
        coordinator().create_for_use_case(UseCase::Mobile)
    }

    /// Create configuration for HPC environments
    pub fn hpc() -> QuantumMCTSConfig {
        coordinator().create_for_use_case(UseCase::HighPerformanceComputing)
    }

    /// Create configuration for development/debugging
    pub fn development() -> QuantumMCTSConfig {
        coordinator().create_for_use_case(UseCase::Development)
    }

    /// Create configuration optimized for testing
    pub fn testing() -> QuantumMCTSConfig {
        coordinator().create_for_use_case(UseCase::Testing)
    }
}

/// Quick access functions for immediate use
pub fn default_config() -> QuantumMCTSConfig {
    factory::default()
}

pub fn performance_config() -> QuantumMCTSConfig {
    factory::performance()
}

pub fn accuracy_config() -> QuantumMCTSConfig {
    factory::accuracy()
}

pub fn system_config() -> QuantumMCTSConfig {
    factory::system_optimized()
}

/// Get system information and recommendations
pub fn system_info() -> SystemCapabilitySummary {
    SystemAnalyzer::new().capability_summary()
}

/// Validate a configuration for current system
pub fn validate(config: &QuantumMCTSConfig) -> Result<(), String> {
    ConfigCoordinator::new().validate_config(config)
}