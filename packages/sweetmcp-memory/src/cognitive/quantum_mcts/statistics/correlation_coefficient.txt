    pub fn correlation_coefficient(x_data: &[f64], y_data: &[f64]) -> f64 {
        if x_data.len() != y_data.len() || x_data.len() < 2 {
            return 0.0;
        }
        
        // Filter paired valid data points
        let valid_pairs: Vec<(f64, f64)> = x_data.iter()
            .zip(y_data.iter())
            .filter(|(&x, &y)| !x.is_nan() && !y.is_nan())
            .map(|(&x, &y)| (x, y))
            .collect();
        
        if valid_pairs.len() < 2 {
            return 0.0;
        }
        
        let n = valid_pairs.len() as f64;
        let mean_x = valid_pairs.iter().map(|(x, _)| *x).sum::<f64>() / n;
        let mean_y = valid_pairs.iter().map(|(_, y)| *y).sum::<f64>() / n;
        
        let mut numerator = 0.0;
        let mut sum_sq_x = 0.0;
        let mut sum_sq_y = 0.0;
        
        for (x, y) in &valid_pairs {
            let diff_x = x - mean_x;
            let diff_y = y - mean_y;
            numerator += diff_x * diff_y;
            sum_sq_x += diff_x * diff_x;
            sum_sq_y += diff_y * diff_y;
        }
        
        let denominator = (sum_sq_x * sum_sq_y).sqrt();
        if denominator <= 1e-10 {
            return 0.0;
        }
        
        (numerator / denominator).clamp(-1.0, 1.0)
    }
