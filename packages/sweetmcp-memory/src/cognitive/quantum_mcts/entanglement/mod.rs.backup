//! Quantum entanglement engine module
//!
//! This module provides a complete quantum entanglement management system for MCTS nodes
//! with zero-allocation patterns, blazing-fast performance, and comprehensive analysis capabilities.

pub mod engine_core;
pub mod engine_operations;
pub mod engine_optimization;
pub mod engine_analysis;
pub mod engine_health;
pub mod engine_health_types;
pub mod engine_issue_types;
pub mod engine_issue_collection;

// Re-export core types and functionality
pub use engine_core::QuantumEntanglementEngine;
pub use engine_operations::{OptimizationResult};
pub use engine_optimization::OptimizationPrediction;
pub use engine_analysis::{EngineHealthReport, NetworkAnalysisReport, OptimizationPriority};
pub use engine_health::{NetworkPerformanceMetrics};
pub use engine_health_types::{CriticalNode, CriticalityType, HealthStatus};
pub use engine_issue_types::{NetworkIssue, IssueSeverity, IssueCategory};
pub use engine_issue_collection::{IssueCollection, IssueSummaryStats};

// Re-export analysis types from parent module
pub use super::analysis::{NetworkTopology, EntanglementDistribution};
pub use super::metrics::EntanglementMetrics;

/// Convenience constructor for quantum entanglement engine
pub fn create_quantum_entanglement_engine(
    manager: std::sync::Arc<super::manager::QuantumEntanglementManager>,
    analyzer: std::sync::Arc<super::analysis::NetworkTopologyAnalyzer>,
    config: super::config::QuantumEntanglementConfig,
) -> QuantumEntanglementEngine {
    QuantumEntanglementEngine::new(manager, analyzer, config)
}

/// Create engine with default configuration
pub fn create_default_quantum_entanglement_engine(
    manager: std::sync::Arc<super::manager::QuantumEntanglementManager>,
    analyzer: std::sync::Arc<super::analysis::NetworkTopologyAnalyzer>,
) -> QuantumEntanglementEngine {
    let config = super::config::QuantumEntanglementConfig::default();
    QuantumEntanglementEngine::new(manager, analyzer, config)
}

/// Optimization utilities
pub mod optimization_utils {
    use super::*;
    
    /// Calculate network health score from multiple metrics
    pub fn calculate_composite_health_score(
        topology: &NetworkTopology,
        metrics: &EntanglementMetrics,
        issues: &IssueCollection,
    ) -> f64 {
        let topology_score = calculate_topology_health_score(topology);
        let metrics_score = calculate_metrics_health_score(metrics);
        let issues_score = issues.health_score();
        
        // Weighted average: topology 40%, metrics 30%, issues 30%
        (topology_score * 0.4) + (metrics_score * 0.3) + (issues_score * 0.3)
    }
    
    /// Calculate health score from topology metrics
    pub fn calculate_topology_health_score(topology: &NetworkTopology) -> f64 {
        let mut score = 0.0;
        
        // Connectivity (25% weight)
        score += if topology.is_connected { 0.25 } else { 0.0 };
        
        // Density (25% weight) - optimal around 0.3
        let density_score = 1.0 - (topology.network_density - 0.3).abs() / 0.3;
        score += density_score.max(0.0) * 0.25;
        
        // Clustering (25% weight) - optimal around 0.5
        let clustering_score = 1.0 - (topology.clustering_coefficient - 0.5).abs() / 0.5;
        score += clustering_score.max(0.0) * 0.25;
        
        // Path length (25% weight) - shorter is better, but not too short
        let path_score = if topology.average_path_length > 0.0 {
            let optimal_path = (topology.total_nodes as f64).log2().max(2.0);
            1.0 - (topology.average_path_length - optimal_path).abs() / optimal_path
        } else {
            0.0
        };
        score += path_score.max(0.0) * 0.25;
        
        score.min(1.0).max(0.0)
    }
    
    /// Calculate health score from entanglement metrics
    pub fn calculate_metrics_health_score(metrics: &EntanglementMetrics) -> f64 {
        let mut score = 1.0;
        
        // Penalize if no entanglements exist
        if metrics.total_entanglements == 0 {
            return 0.0;
        }
        
        // Reward balanced strength distribution
        if metrics.average_strength > 0.0 {
            let strength_balance = 1.0 - (metrics.max_strength - metrics.average_strength) / metrics.max_strength;
            score *= strength_balance.max(0.5); // Don't penalize too heavily
        }
        
        // Reward reasonable entanglement density
        let density_factor = if metrics.total_entanglements > 1000 {
            0.9 // Slight penalty for very large networks
        } else if metrics.total_entanglements < 10 {
            0.8 // Penalty for very small networks
        } else {
            1.0
        };
        score *= density_factor;
        
        score.min(1.0).max(0.0)
    }
    
    /// Recommend optimization strategy based on network state
    pub fn recommend_optimization_strategy(
        topology: &NetworkTopology,
        metrics: &EntanglementMetrics,
        issues: &IssueCollection,
    ) -> OptimizationStrategy {
        let health_score = calculate_composite_health_score(topology, metrics, issues);
        
        if health_score < 0.3 {
            OptimizationStrategy::Emergency
        } else if health_score < 0.6 {
            OptimizationStrategy::Aggressive
        } else if health_score < 0.8 {
            OptimizationStrategy::Moderate
        } else {
            OptimizationStrategy::Maintenance
        }
    }
    
    /// Calculate optimization urgency level
    pub fn calculate_optimization_urgency(
        topology: &NetworkTopology,
        issues: &IssueCollection,
    ) -> OptimizationUrgency {
        let critical_issues = issues.critical_issues();
        let connectivity_issues = issues.connectivity_issues();
        
        if !critical_issues.is_empty() || !topology.is_connected {
            OptimizationUrgency::Immediate
        } else if connectivity_issues.len() > 2 || topology.network_density < 0.05 {
            OptimizationUrgency::High
        } else if issues.issues.len() > 5 || topology.clustering_coefficient < 0.1 {
            OptimizationUrgency::Medium
        } else {
            OptimizationUrgency::Low
        }
    }
}

/// Optimization strategy recommendations
#[derive(Debug, Clone, PartialEq)]
pub enum OptimizationStrategy {
    Emergency,    // Immediate comprehensive optimization required
    Aggressive,   // Significant optimization needed
    Moderate,     // Regular optimization recommended
    Maintenance,  // Light maintenance optimization only
}

impl OptimizationStrategy {
    /// Get strategy description
    pub fn description(&self) -> &'static str {
        match self {
            OptimizationStrategy::Emergency => "Emergency optimization - network is in critical state",
            OptimizationStrategy::Aggressive => "Aggressive optimization - significant improvements needed",
            OptimizationStrategy::Moderate => "Moderate optimization - regular improvements recommended",
            OptimizationStrategy::Maintenance => "Maintenance optimization - light tuning only",
        }
    }
    
    /// Get recommended optimization frequency in hours
    pub fn frequency_hours(&self) -> u32 {
        match self {
            OptimizationStrategy::Emergency => 1,    // Every hour
            OptimizationStrategy::Aggressive => 4,   // Every 4 hours
            OptimizationStrategy::Moderate => 12,    // Twice daily
            OptimizationStrategy::Maintenance => 24, // Daily
        }
    }
}

/// Optimization urgency levels
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum OptimizationUrgency {
    Low,
    Medium,
    High,
    Immediate,
}

impl OptimizationUrgency {
    /// Get urgency description
    pub fn description(&self) -> &'static str {
        match self {
            OptimizationUrgency::Low => "Low urgency - optimize during next maintenance window",
            OptimizationUrgency::Medium => "Medium urgency - optimize within 24 hours",
            OptimizationUrgency::High => "High urgency - optimize within 4 hours",
            OptimizationUrgency::Immediate => "Immediate urgency - optimize now",
        }
    }
    
    /// Get maximum wait time in minutes
    pub fn max_wait_minutes(&self) -> u32 {
        match self {
            OptimizationUrgency::Low => 1440,      // 24 hours
            OptimizationUrgency::Medium => 720,    // 12 hours
            OptimizationUrgency::High => 240,      // 4 hours
            OptimizationUrgency::Immediate => 0,   // Now
        }
    }
}

/// Health monitoring utilities
pub mod health_utils {
    use super::*;
    
    /// Create comprehensive health report
    pub async fn create_comprehensive_health_report(
        engine: &QuantumEntanglementEngine,
    ) -> Result<ComprehensiveHealthReport, crate::cognitive::types::CognitiveError> {
        let analysis_report = engine.generate_analysis_report().await?;
        let optimization_prediction = engine.predict_optimization_impact(
            &analysis_report.topology,
            &std::collections::HashMap::new(), // Would need actual tree in real implementation
        );
        
        Ok(ComprehensiveHealthReport {
            analysis_report,
            optimization_prediction,
            generated_at: std::time::SystemTime::now(),
        })
    }
    
    /// Monitor health trends over time
    pub fn analyze_health_trends(
        historical_reports: &[ComprehensiveHealthReport],
    ) -> HealthTrend {
        if historical_reports.len() < 2 {
            return HealthTrend::Insufficient;
        }
        
        let recent_health = historical_reports.last().unwrap().analysis_report.health.overall_health;
        let previous_health = historical_reports[historical_reports.len() - 2].analysis_report.health.overall_health;
        
        let change = recent_health - previous_health;
        
        if change > 5.0 {
            HealthTrend::Improving
        } else if change < -5.0 {
            HealthTrend::Declining
        } else {
            HealthTrend::Stable
        }
    }
}

/// Comprehensive health report combining multiple analysis types
#[derive(Debug, Clone)]
pub struct ComprehensiveHealthReport {
    pub analysis_report: NetworkAnalysisReport,
    pub optimization_prediction: OptimizationPrediction,
    pub generated_at: std::time::SystemTime,
}

impl ComprehensiveHealthReport {
    /// Get overall health grade
    pub fn health_grade(&self) -> char {
        let health_score = self.analysis_report.health.overall_health;
        if health_score >= 90.0 {
            'A'
        } else if health_score >= 80.0 {
            'B'
        } else if health_score >= 70.0 {
            'C'
        } else if health_score >= 60.0 {
            'D'
        } else {
            'F'
        }
    }
    
    /// Check if optimization is strongly recommended
    pub fn strongly_recommends_optimization(&self) -> bool {
        self.analysis_report.recommends_optimization() && 
        self.optimization_prediction.is_optimization_recommended()
    }
}

/// Health trend analysis
#[derive(Debug, Clone, PartialEq)]
pub enum HealthTrend {
    Improving,
    Stable,
    Declining,
    Insufficient, // Not enough data
}

impl HealthTrend {
    /// Get trend description
    pub fn description(&self) -> &'static str {
        match self {
            HealthTrend::Improving => "Network health is improving over time",
            HealthTrend::Stable => "Network health is stable",
            HealthTrend::Declining => "Network health is declining - attention needed",
            HealthTrend::Insufficient => "Insufficient data to determine trend",
        }
    }
    
    /// Check if trend indicates problems
    pub fn indicates_problems(&self) -> bool {
        matches!(self, HealthTrend::Declining)
    }
}