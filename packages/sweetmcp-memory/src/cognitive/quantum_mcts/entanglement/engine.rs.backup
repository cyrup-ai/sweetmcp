//! High-level entanglement management engine for quantum MCTS
//!
//! This module provides blazing-fast entanglement optimization with
//! zero-allocation patterns and comprehensive performance tracking.

use std::collections::HashMap;
use std::sync::Arc;
use std::time::Instant;
use tokio::sync::RwLock;
use tracing::{debug, info, warn};

use crate::cognitive::{
    quantum::EntanglementGraph,
    types::CognitiveError,
};
use super::{
    core::QuantumEntanglementManager,
    analysis::{NetworkTopology, NetworkTopologyAnalyzer},
    metrics::{EntanglementMetrics, PerformanceTracker},
};
use super::super::{
    node_state::QuantumMCTSNode,
    config::QuantumMCTSConfig,
};

/// High-level entanglement management interface with optimization capabilities
pub struct QuantumEntanglementEngine {
    /// Core entanglement manager
    manager: QuantumEntanglementManager,
    /// Performance metrics tracker
    metrics: Arc<EntanglementMetrics>,
    /// Configuration parameters
    config: QuantumMCTSConfig,
    /// Reference to the entanglement graph
    entanglement_graph: Arc<RwLock<EntanglementGraph>>,
}

impl QuantumEntanglementEngine {
    /// Create new entanglement engine with comprehensive initialization
    pub fn new(
        config: QuantumMCTSConfig,
        entanglement_graph: Arc<RwLock<EntanglementGraph>>,
    ) -> Self {
        let metrics = Arc::new(EntanglementMetrics::new());
        let manager = QuantumEntanglementManager::new(
            config.clone(),
            entanglement_graph.clone(),
            metrics.clone(),
        );
        
        Self {
            manager,
            metrics,
            config,
            entanglement_graph,
        }
    }
    
    /// Create entanglement engine with custom metrics
    pub fn with_metrics(
        config: QuantumMCTSConfig,
        entanglement_graph: Arc<RwLock<EntanglementGraph>>,
        metrics: Arc<EntanglementMetrics>,
    ) -> Self {
        let manager = QuantumEntanglementManager::new(
            config.clone(),
            entanglement_graph.clone(),
            metrics.clone(),
        );
        
        Self {
            manager,
            metrics,
            config,
            entanglement_graph,
        }
    }
    
    /// Perform automatic entanglement optimization with comprehensive analysis
    pub async fn optimize_entanglements(
        &mut self,
        tree: &mut HashMap<String, QuantumMCTSNode>,
    ) -> Result<OptimizationResult, CognitiveError> {
        let _tracker = PerformanceTracker::start();
        let start_time = Instant::now();
        
        debug!("Starting entanglement optimization for {} nodes", tree.len());
        
        // Analyze current topology
        let initial_topology = NetworkTopologyAnalyzer::analyze_network_topology(&self.entanglement_graph).await?;
        self.metrics.record_topology_analysis();
        
        let mut actions_taken = Vec::new();
        let mut total_created = 0;
        let mut total_pruned = 0;
        
        // Step 1: Prune weak entanglements if network is overly dense
        if initial_topology.is_overly_dense() {
            let pruning_threshold = self.calculate_dynamic_pruning_threshold(&initial_topology);
            let pruned = self.manager.prune_weak_entanglements(pruning_threshold).await?;
            
            if pruned > 0 {
                total_pruned += pruned;
                actions_taken.push(format!("Pruned {} weak entanglements (threshold: {:.3})", pruned, pruning_threshold));
                self.metrics.record_entanglements_pruned(pruned);
            }
        }
        
        // Step 2: Create new entanglements if network is sparse or poorly connected
        if initial_topology.is_sparse() || !initial_topology.has_good_connectivity() {
            let creation_result = self.create_strategic_entanglements(tree).await?;
            total_created += creation_result.entanglements_created;
            
            if creation_result.entanglements_created > 0 {
                actions_taken.push(format!(
                    "Created {} strategic entanglements across {} batches",
                    creation_result.entanglements_created,
                    creation_result.batches_processed
                ));
            }
        }
        
        // Step 3: Balance entanglement distribution
        let balancing_result = self.balance_entanglement_distribution(tree).await?;
        if balancing_result.rebalanced_nodes > 0 {
            actions_taken.push(format!(
                "Rebalanced entanglements for {} nodes",
                balancing_result.rebalanced_nodes
            ));
        }
        
        // Step 4: Update node entanglement states
        let mut update_failures = 0;
        for node_id in tree.keys().cloned().collect::<Vec<_>>() {
            if let Err(e) = self.manager.update_node_entanglements(&node_id, tree).await {
                warn!("Failed to update entanglements for node {}: {}", node_id, e);
                update_failures += 1;
            }
        }
        
        if update_failures > 0 {
            actions_taken.push(format!("Failed to update {} node entanglement states", update_failures));
        }
        
        // Analyze final topology
        let final_topology = NetworkTopologyAnalyzer::analyze_network_topology(&self.entanglement_graph).await?;
        self.metrics.record_topology_analysis();
        
        let optimization_time = start_time.elapsed();
        
        let result = OptimizationResult {
            initial_topology,
            final_topology,
            actions_taken,
            optimization_time_ms: optimization_time.as_millis() as u64,
            entanglements_created: total_created,
            entanglements_pruned: total_pruned,
            nodes_processed: tree.len(),
            update_failures,
            performance_improvement: 0.0, // Will be calculated
        };
        
        // Calculate performance improvement
        let improved_result = self.calculate_performance_improvement(result).await?;
        
        info!(
            "Entanglement optimization completed in {}ms: {}",
            improved_result.optimization_time_ms,
            improved_result.summary()
        );
        
        Ok(improved_result)
    }
    
    /// Create strategic entanglements to improve network connectivity
    async fn create_strategic_entanglements(
        &mut self,
        tree: &HashMap<String, QuantumMCTSNode>,
    ) -> Result<CreationResult, CognitiveError> {
        let node_ids: Vec<String> = tree.keys().cloned().collect();
        let batch_size = self.calculate_optimal_batch_size(node_ids.len());
        
        let mut total_created = 0;
        let mut batches_processed = 0;
        
        // Process nodes in strategic batches
        for chunk in node_ids.chunks(batch_size) {
            let batch_results = self.manager.batch_create_entanglements(chunk, tree).await?;
            
            let batch_created: usize = batch_results.values().map(|v| v.len()).sum();
            total_created += batch_created;
            batches_processed += 1;
            
            if batch_created > 0 {
                debug!("Batch {}: created {} entanglements for {} nodes", 
                       batches_processed, batch_created, chunk.len());
            }
            
            // Prevent excessive computation
            if total_created >= 1000 {
                debug!("Reached entanglement creation limit ({}), stopping early", total_created);
                break;
            }
        }
        
        Ok(CreationResult {
            entanglements_created: total_created,
            batches_processed,
        })
    }
    
    /// Balance entanglement distribution across the network
    async fn balance_entanglement_distribution(
        &mut self,
        tree: &HashMap<String, QuantumMCTSNode>,
    ) -> Result<BalancingResult, CognitiveError> {
        let graph = self.entanglement_graph.read().await;
        let mut rebalanced_nodes = 0;
        
        // Find nodes with excessive entanglements
        let mut over_entangled_nodes = Vec::new();
        let mut under_entangled_nodes = Vec::new();
        
        let average_degree = if graph.node_count() > 0 {
            (graph.entanglement_count() * 2) as f64 / graph.node_count() as f64
        } else {
            0.0
        };
        
        let over_threshold = (average_degree * 2.0).max(10.0);
        let under_threshold = (average_degree * 0.5).max(1.0);
        
        for node_id in tree.keys() {
            let degree = graph.degree(node_id).unwrap_or(0) as f64;
            
            if degree > over_threshold {
                over_entangled_nodes.push(node_id.clone());
            } else if degree < under_threshold {
                under_entangled_nodes.push(node_id.clone());
            }
        }
        
        drop(graph); // Release read lock
        
        // Rebalance by pruning from over-entangled nodes
        for node_id in &over_entangled_nodes {
            let pruned = self.prune_node_weak_entanglements(node_id, 0.3).await?;
            if pruned > 0 {
                rebalanced_nodes += 1;
                debug!("Pruned {} weak entanglements from over-entangled node {}", pruned, node_id);
            }
        }
        
        debug!(
            "Entanglement balancing: {} over-entangled, {} under-entangled, {} rebalanced",
            over_entangled_nodes.len(),
            under_entangled_nodes.len(),
            rebalanced_nodes
        );
        
        Ok(BalancingResult {
            over_entangled_nodes: over_entangled_nodes.len(),
            under_entangled_nodes: under_entangled_nodes.len(),
            rebalanced_nodes,
        })
    }
    
    /// Prune weak entanglements for a specific node
    async fn prune_node_weak_entanglements(
        &mut self,
        node_id: &str,
        strength_threshold: f64,
    ) -> Result<usize, CognitiveError> {
        let mut graph = self.entanglement_graph.write().await;
        
        let entangled_nodes = graph.get_entangled(node_id)
            .map_err(|e| CognitiveError::QuantumError(format!("Failed to get entangled nodes: {}", e)))?;
        
        let mut pruned_count = 0;
        
        for (entangled_id, strength) in entangled_nodes {
            if strength < strength_threshold {
                match graph.remove_entanglement(node_id, &entangled_id) {
                    Ok(true) => {
                        pruned_count += 1;
                        debug!("Pruned weak entanglement: {} <-> {} (strength: {:.3})", 
                               node_id, entangled_id, strength);
                    }
                    Ok(false) => {
                        // Entanglement didn't exist (race condition)
                    }
                    Err(e) => {
                        warn!("Failed to remove entanglement {} <-> {}: {}", node_id, entangled_id, e);
                    }
                }
            }
        }
        
        if pruned_count > 0 {
            self.metrics.record_entanglements_pruned(pruned_count);
        }
        
        Ok(pruned_count)
    }
    
    /// Calculate dynamic pruning threshold based on network state
    fn calculate_dynamic_pruning_threshold(&self, topology: &NetworkTopology) -> f64 {
        let base_threshold = 0.1;
        
        // Increase threshold for very dense networks
        let density_adjustment = if topology.network_density > 0.5 {
            topology.network_density * 0.2
        } else {
            0.0
        };
        
        // Increase threshold if average degree is very high
        let degree_adjustment = if topology.average_degree > 15.0 {
            (topology.average_degree - 15.0) * 0.01
        } else {
            0.0
        };
        
        (base_threshold + density_adjustment + degree_adjustment).min(0.5)
    }
    
    /// Calculate optimal batch size for entanglement creation
    fn calculate_optimal_batch_size(&self, total_nodes: usize) -> usize {
        // Balance between parallelism and memory usage
        let base_batch_size = 20;
        let scaled_batch_size = (total_nodes / 10).max(base_batch_size).min(100);
        scaled_batch_size
    }
    
    /// Calculate performance improvement from optimization
    async fn calculate_performance_improvement(
        &self,
        mut result: OptimizationResult,
    ) -> Result<OptimizationResult, CognitiveError> {
        let initial_efficiency = result.initial_topology.efficiency_score();
        let final_efficiency = result.final_topology.efficiency_score();
        
        result.performance_improvement = ((final_efficiency - initial_efficiency) / initial_efficiency.max(0.01)) * 100.0;
        
        Ok(result)
    }
    
    /// Perform intelligent entanglement pruning based on network analysis
    pub async fn intelligent_pruning(
        &mut self,
        tree: &HashMap<String, QuantumMCTSNode>,
    ) -> Result<PruningResult, CognitiveError> {
        let start_time = Instant::now();
        
        // Analyze network quality
        let topology = NetworkTopologyAnalyzer::analyze_network_topology(&self.entanglement_graph).await?;
        
        if !topology.is_overly_dense() {
            return Ok(PruningResult {
                entanglements_pruned: 0,
                pruning_time_ms: start_time.elapsed().as_millis() as u64,
                network_improvement: 0.0,
                reason: "Network is not overly dense, pruning not needed".to_string(),
            });
        }
        
        // Calculate adaptive pruning parameters
        let pruning_threshold = self.calculate_adaptive_pruning_threshold(&topology, tree).await?;
        let initial_count = topology.total_entanglements;
        
        // Perform pruning
        let pruned_count = self.manager.prune_weak_entanglements(pruning_threshold).await?;
        
        // Analyze improvement
        let final_topology = NetworkTopologyAnalyzer::analyze_network_topology(&self.entanglement_graph).await?;
        let network_improvement = final_topology.efficiency_score() - topology.efficiency_score();
        
        let pruning_time = start_time.elapsed();
        
        info!(
            "Intelligent pruning completed: {} entanglements pruned (threshold: {:.3}), improvement: {:.1}%",
            pruned_count,
            pruning_threshold,
            network_improvement * 100.0
        );
        
        Ok(PruningResult {
            entanglements_pruned: pruned_count,
            pruning_time_ms: pruning_time.as_millis() as u64,
            network_improvement: network_improvement * 100.0,
            reason: format!(
                "Pruned {} of {} entanglements using adaptive threshold {:.3}",
                pruned_count, initial_count, pruning_threshold
            ),
        })
    }
    
    /// Calculate adaptive pruning threshold based on network analysis
    async fn calculate_adaptive_pruning_threshold(
        &self,
        topology: &NetworkTopology,
        tree: &HashMap<String, QuantumMCTSNode>,
    ) -> Result<f64, CognitiveError> {
        // Base threshold from configuration
        let mut threshold = 0.1;
        
        // Adjust based on network density
        if topology.network_density > 0.6 {
            threshold += 0.1; // More aggressive pruning for very dense networks
        }
        
        // Adjust based on clustering coefficient
        if topology.clustering_coefficient > 0.8 {
            threshold += 0.05; // Prune more if network is highly clustered
        }
        
        // Adjust based on node quality distribution
        let node_qualities: Vec<f64> = tree.values()
            .filter(|node| node.visits > 0)
            .map(|node| node.quantum_reward.norm() / node.visits as f64)
            .collect();
        
        if !node_qualities.is_empty() {
            let avg_quality: f64 = node_qualities.iter().sum::<f64>() / node_qualities.len() as f64;
            
            // If average node quality is low, be more conservative with pruning
            if avg_quality < 0.3 {
                threshold -= 0.05;
            } else if avg_quality > 0.7 {
                threshold += 0.05;
            }
        }
        
        // Ensure threshold is within reasonable bounds
        Ok(threshold.max(0.05).min(0.4))
    }
    
    /// Get manager reference for direct operations
    pub fn manager(&mut self) -> &mut QuantumEntanglementManager {
        &mut self.manager
    }
    
    /// Get metrics reference
    pub fn metrics(&self) -> &EntanglementMetrics {
        &self.metrics
    }
    
    /// Get current configuration
    pub fn config(&self) -> &QuantumMCTSConfig {
        &self.config
    }
    
    /// Update configuration and clear caches
    pub fn update_config(&mut self, new_config: QuantumMCTSConfig) {
        self.config = new_config.clone();
        self.manager.update_config(new_config);
    }
    
    /// Perform comprehensive network health check
    pub async fn health_check(&self) -> Result<NetworkHealthReport, CognitiveError> {
        let topology = NetworkTopologyAnalyzer::analyze_network_topology(&self.entanglement_graph).await?;
        let metrics_summary = self.metrics.summary();
        
        let health_score = self.calculate_network_health_score(&topology, &metrics_summary);
        let issues = self.identify_health_issues(&topology, &metrics_summary);
        let recommendations = self.generate_health_recommendations(&topology, &metrics_summary);
        
        Ok(NetworkHealthReport {
            topology,
            metrics_summary,
            health_score,
            issues,
            recommendations,
            timestamp: Instant::now(),
        })
    }
    
    /// Calculate overall network health score
    fn calculate_network_health_score(
        &self,
        topology: &NetworkTopology,
        metrics: &super::metrics::EntanglementMetricsSummary,
    ) -> f64 {
        let topology_score = topology.efficiency_score();
        let performance_score = if metrics.has_good_performance() { 1.0 } else { 0.5 };
        let stability_score = if metrics.success_rate > 0.8 { 1.0 } else { metrics.success_rate };
        
        // Weighted combination of health factors
        (topology_score * 0.4 + performance_score * 0.3 + stability_score * 0.3).max(0.0).min(1.0)
    }
    
    /// Identify network health issues
    fn identify_health_issues(
        &self,
        topology: &NetworkTopology,
        metrics: &super::metrics::EntanglementMetricsSummary,
    ) -> Vec<String> {
        let mut issues = Vec::new();
        
        if topology.is_sparse() {
            issues.push("Network connectivity is too sparse".to_string());
        }
        
        if topology.is_overly_dense() {
            issues.push("Network is overly dense, may impact performance".to_string());
        }
        
        if !topology.is_connected {
            issues.push("Network has disconnected components".to_string());
        }
        
        if metrics.has_performance_issues() {
            issues.push(format!("Performance issues detected (grade: {})", metrics.performance_grade()));
        }
        
        if metrics.success_rate < 0.7 {
            issues.push(format!("Low operation success rate: {:.1}%", metrics.success_rate * 100.0));
        }
        
        if metrics.cache_hit_rate < 0.5 {
            issues.push(format!("Low cache efficiency: {:.1}%", metrics.cache_hit_rate * 100.0));
        }
        
        if issues.is_empty() {
            issues.push("No significant health issues detected".to_string());
        }
        
        issues
    }
    
    /// Generate health improvement recommendations
    fn generate_health_recommendations(
        &self,
        topology: &NetworkTopology,
        metrics: &super::metrics::EntanglementMetricsSummary,
    ) -> Vec<String> {
        let mut recommendations = Vec::new();
        
        recommendations.extend(topology.optimization_recommendations());
        recommendations.extend(metrics.performance_recommendations());
        
        // Additional engine-specific recommendations
        if topology.total_nodes > 1000 && topology.average_degree < 3.0 {
            recommendations.push("Consider increasing batch size for large networks".to_string());
        }
        
        if metrics.operations_per_second < 50.0 && metrics.entanglement_operations > 100 {
            recommendations.push("Consider parallel processing for better throughput".to_string());
        }
        
        recommendations
    }
}

/// Entanglement optimization result with comprehensive analysis
#[derive(Debug, Clone)]
pub struct OptimizationResult {
    /// Initial network topology before optimization
    pub initial_topology: NetworkTopology,
    /// Final network topology after optimization
    pub final_topology: NetworkTopology,
    /// List of optimization actions taken
    pub actions_taken: Vec<String>,
    /// Time taken for optimization in milliseconds
    pub optimization_time_ms: u64,
    /// Number of entanglements created
    pub entanglements_created: usize,
    /// Number of entanglements pruned
    pub entanglements_pruned: usize,
    /// Number of nodes processed
    pub nodes_processed: usize,
    /// Number of node update failures
    pub update_failures: usize,
    /// Performance improvement percentage
    pub performance_improvement: f64,
}

impl OptimizationResult {
    /// Check if optimization improved the network
    pub fn was_beneficial(&self) -> bool {
        self.final_topology.has_good_connectivity() && 
        !self.final_topology.is_overly_dense() &&
        self.performance_improvement >= -5.0 && // Allow small degradation
        self.final_topology.total_entanglements >= 
            self.initial_topology.total_entanglements.saturating_sub(self.entanglements_pruned)
    }
    
    /// Get optimization summary
    pub fn summary(&self) -> String {
        let entanglement_change = self.final_topology.total_entanglements as i64 - 
                                 self.initial_topology.total_entanglements as i64;
        let density_change = self.final_topology.network_density - self.initial_topology.network_density;
        
        format!(
            "Entanglements: {} ({:+}), Density: {:.3} ({:+.3}), Performance: {:+.1}%, Actions: {}",
            self.final_topology.total_entanglements,
            entanglement_change,
            self.final_topology.network_density,
            density_change,
            self.performance_improvement,
            self.actions_taken.len()
        )
    }
    
    /// Get detailed report
    pub fn detailed_report(&self) -> String {
        let mut report = String::new();
        
        report.push_str(&format!("Entanglement Optimization Report:\n"));
        report.push_str(&format!("Duration: {}ms\n", self.optimization_time_ms));
        report.push_str(&format!("Nodes processed: {}\n", self.nodes_processed));
        report.push_str(&format!("Created: {}, Pruned: {}\n", self.entanglements_created, self.entanglements_pruned));
        
        if self.update_failures > 0 {
            report.push_str(&format!("Update failures: {}\n", self.update_failures));
        }
        
        report.push_str(&format!("Performance improvement: {:+.1}%\n", self.performance_improvement));
        report.push_str(&format!("Beneficial: {}\n", self.was_beneficial()));
        
        report.push_str("\nActions taken:\n");
        for (i, action) in self.actions_taken.iter().enumerate() {
            report.push_str(&format!("  {}. {}\n", i + 1, action));
        }
        
        report.push_str("\nTopology changes:\n");
        report.push_str(&format!("  Nodes: {} → {}\n", 
                                 self.initial_topology.total_nodes, 
                                 self.final_topology.total_nodes));
        report.push_str(&format!("  Entanglements: {} → {}\n", 
                                 self.initial_topology.total_entanglements, 
                                 self.final_topology.total_entanglements));
        report.push_str(&format!("  Density: {:.3} → {:.3}\n", 
                                 self.initial_topology.network_density, 
                                 self.final_topology.network_density));
        report.push_str(&format!("  Connected: {} → {}\n", 
                                 self.initial_topology.is_connected, 
                                 self.final_topology.is_connected));
        
        report
    }
}

/// Strategic entanglement creation result
#[derive(Debug, Clone)]
struct CreationResult {
    /// Number of entanglements created
    entanglements_created: usize,
    /// Number of batches processed
    batches_processed: usize,
}

/// Entanglement distribution balancing result
#[derive(Debug, Clone)]
struct BalancingResult {
    /// Number of over-entangled nodes found
    over_entangled_nodes: usize,
    /// Number of under-entangled nodes found
    under_entangled_nodes: usize,
    /// Number of nodes rebalanced
    rebalanced_nodes: usize,
}

/// Intelligent pruning result
#[derive(Debug, Clone)]
pub struct PruningResult {
    /// Number of entanglements pruned
    pub entanglements_pruned: usize,
    /// Time taken for pruning in milliseconds
    pub pruning_time_ms: u64,
    /// Network improvement percentage
    pub network_improvement: f64,
    /// Reason for pruning decision
    pub reason: String,
}

/// Comprehensive network health report
#[derive(Debug, Clone)]
pub struct NetworkHealthReport {
    /// Current network topology
    pub topology: NetworkTopology,
    /// Performance metrics summary
    pub metrics_summary: super::metrics::EntanglementMetricsSummary,
    /// Overall health score (0.0 to 1.0)
    pub health_score: f64,
    /// Identified health issues
    pub issues: Vec<String>,
    /// Improvement recommendations
    pub recommendations: Vec<String>,
    /// Report timestamp
    pub timestamp: Instant,
}

impl NetworkHealthReport {
    /// Get health grade (A-F)
    pub fn health_grade(&self) -> char {
        if self.health_score >= 0.9 { 'A' }
        else if self.health_score >= 0.8 { 'B' }
        else if self.health_score >= 0.7 { 'C' }
        else if self.health_score >= 0.6 { 'D' }
        else { 'F' }
    }
    
    /// Check if network is healthy
    pub fn is_healthy(&self) -> bool {
        self.health_score >= 0.7
    }
    
    /// Format health report for display
    pub fn format_report(&self) -> String {
        let mut report = String::new();
        
        report.push_str(&format!("Network Health Report (Grade: {})\n", self.health_grade()));
        report.push_str(&format!("Health Score: {:.1}/10\n", self.health_score * 10.0));
        report.push_str(&format!("Timestamp: {:?}\n\n", self.timestamp));
        
        report.push_str("Network Topology:\n");
        report.push_str(&format!("  Nodes: {}, Entanglements: {}\n", 
                                 self.topology.total_nodes, 
                                 self.topology.total_entanglements));
        report.push_str(&format!("  Density: {:.3}, Connected: {}\n", 
                                 self.topology.network_density, 
                                 self.topology.is_connected));
        report.push_str(&format!("  Avg Degree: {:.1}, Max Degree: {}\n\n", 
                                 self.topology.average_degree, 
                                 self.topology.max_degree));
        
        report.push_str("Performance Metrics:\n");
        report.push_str(&format!("  Success Rate: {:.1}%, Cache Hit Rate: {:.1}%\n", 
                                 self.metrics_summary.success_rate * 100.0,
                                 self.metrics_summary.cache_hit_rate * 100.0));
        report.push_str(&format!("  Throughput: {:.1} ops/sec, Latency: {:.1}μs\n\n", 
                                 self.metrics_summary.operations_per_second,
                                 self.metrics_summary.average_operation_time_us));
        
        report.push_str("Issues Identified:\n");
        for (i, issue) in self.issues.iter().enumerate() {
            report.push_str(&format!("  {}. {}\n", i + 1, issue));
        }
        
        report.push_str("\nRecommendations:\n");
        for (i, rec) in self.recommendations.iter().enumerate() {
            report.push_str(&format!("  {}. {}\n", i + 1, rec));
        }
        
        report
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cognitive::mcts::CodeState;
    
    #[tokio::test]
    async fn test_entanglement_engine_creation() {
        let config = QuantumMCTSConfig::default();
        let entanglement_graph = Arc::new(RwLock::new(EntanglementGraph::new()));
        let engine = QuantumEntanglementEngine::new(config, entanglement_graph);
        
        assert_eq!(engine.metrics().entanglements_created(), 0);
        assert_eq!(engine.config().decoherence_threshold, QuantumMCTSConfig::default().decoherence_threshold);
    }
    
    #[test]
    fn test_optimization_result_analysis() {
        let initial_topology = NetworkTopology {
            total_nodes: 100,
            total_entanglements: 50,
            average_degree: 1.0,
            max_degree: 5,
            network_density: 0.01,
            is_connected: false,
            clustering_coefficient: 0.1,
        };
        
        let final_topology = NetworkTopology {
            total_nodes: 100,
            total_entanglements: 150,
            average_degree: 3.0,
            max_degree: 8,
            network_density: 0.03,
            is_connected: true,
            clustering_coefficient: 0.4,
        };
        
        let result = OptimizationResult {
            initial_topology,
            final_topology,
            actions_taken: vec!["Created 100 entanglements".to_string()],
            optimization_time_ms: 100,
            entanglements_created: 100,
            entanglements_pruned: 0,
            nodes_processed: 100,
            update_failures: 0,
            performance_improvement: 25.0,
        };
        
        assert!(result.was_beneficial());
        let summary = result.summary();
        assert!(summary.contains("+100"));
        assert!(summary.contains("+25.0%"));
    }
    
    #[test]
    fn test_pruning_result() {
        let result = PruningResult {
            entanglements_pruned: 50,
            pruning_time_ms: 200,
            network_improvement: 15.0,
            reason: "Network was overly dense".to_string(),
        };
        
        assert_eq!(result.entanglements_pruned, 50);
        assert_eq!(result.network_improvement, 15.0);
        assert!(result.reason.contains("overly dense"));
    }
    
    #[test]
    fn test_network_health_report() {
        let topology = NetworkTopology {
            total_nodes: 100,
            total_entanglements: 150,
            average_degree: 3.0,
            max_degree: 8,
            network_density: 0.03,
            is_connected: true,
            clustering_coefficient: 0.4,
        };
        
        let metrics = super::metrics::EntanglementMetricsSummary {
            entanglements_created: 100,
            entanglements_removed: 10,
            entanglements_pruned: 5,
            net_entanglements: 85,
            entanglement_operations: 100,
            entanglement_failures: 5,
            success_rate: 0.95,
            cache_hit_rate: 0.8,
            average_operation_time_us: 500.0,
            operations_per_second: 200.0,
            topology_analyses: 10,
            influence_calculations: 50,
            average_influence_time_us: 300.0,
            influence_calculations_per_second: 100.0,
            uptime_seconds: 3600,
        };
        
        let report = NetworkHealthReport {
            topology,
            metrics_summary: metrics,
            health_score: 0.85,
            issues: vec!["No issues".to_string()],
            recommendations: vec!["Continue monitoring".to_string()],
            timestamp: Instant::now(),
        };
        
        assert_eq!(report.health_grade(), 'B');
        assert!(report.is_healthy());
        
        let formatted = report.format_report();
        assert!(formatted.contains("Grade: B"));
        assert!(formatted.contains("Health Score: 8.5"));
    }
}