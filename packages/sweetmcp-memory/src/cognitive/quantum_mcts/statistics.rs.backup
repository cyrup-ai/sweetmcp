//! Statistics and utilities with incremental updates and lock-free metrics
//!
//! This module provides blazing-fast quantum MCTS statistics collection with
//! lock-free atomic operations, incremental updates, and zero-allocation analysis.
//!
//! ## Architecture
//!
//! The statistics system is decomposed into focused submodules:
//! - `collector`: Core QuantumStatisticsCollector with atomic operations
//! - `tree_stats`: Tree-specific statistics structures and analysis
//! - `performance`: Performance and throughput metrics with bottleneck analysis
//! - `trends`: Historical trend analysis and prediction
//! - `analysis`: Mathematical analysis utilities and algorithms
//!
//! ## Usage
//!
//! ```rust
//! use sweetmcp_memory::cognitive::quantum_mcts::statistics::*;
//!
//! // Create statistics coordinator
//! let config = QuantumMCTSConfig::default();
//! let coordinator = StatisticsCoordinator::new(config);
//!
//! // Collect comprehensive statistics
//! let stats = coordinator.collect_comprehensive_statistics(
//!     &tree, &entanglement_graph, &quantum_metrics
//! ).await?;
//!
//! // Analyze trends and get recommendations
//! let assessment = coordinator.get_performance_assessment().await?;
//! ```

use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use serde::Serialize;
use tokio::sync::RwLock;
use tracing::{debug, trace};

use crate::cognitive::{
    quantum::{Complex64, EntanglementGraph, QuantumMetrics},
    types::CognitiveError,
};
use super::{
    node_state::{QuantumMCTSNode, QuantumNodeState},
    config::QuantumMCTSConfig,
};

// Import submodules - these are in the statistics/ directory
use self::collector::{QuantumStatisticsCollector, CounterSnapshot};
use self::tree_stats::{
    QuantumTreeStatistics, DepthStatistics, RewardStatistics, ConvergenceMetrics,
    RewardQuality, ConvergencePhase, ConvergenceHealth,
};
use self::performance::{
    PerformanceMetrics, ThroughputMetrics, PerformanceBottleneck, PerformanceTrend,
    ThroughputAnalysis, Priority,
};
use self::trends::{
    StatisticsSnapshot, PerformanceTrends, PerformancePrediction, PredictionReliability,
    TrendRecommendation, TrendMomentum, SnapshotComparison,
};
use self::analysis::StatisticsUtils;

// Declare submodules
pub mod collector;
pub mod tree_stats;
pub mod performance;
pub mod trends;
pub mod analysis;
pub mod types;
pub mod metrics;
pub mod coordinator;

// Re-export all types for backward compatibility
pub use collector::{QuantumStatisticsCollector, CounterSnapshot};
pub use tree_stats::{
    QuantumTreeStatistics, DepthStatistics, RewardStatistics, ConvergenceMetrics,
    RewardQuality, ConvergencePhase, ConvergenceHealth,
};
pub use performance::{
    PerformanceMetrics, ThroughputMetrics, PerformanceBottleneck, PerformanceTrend,
    ThroughputAnalysis, Priority,
};
pub use trends::{
    StatisticsSnapshot, PerformanceTrends, PerformancePrediction, PredictionReliability,
    TrendRecommendation, TrendMomentum, SnapshotComparison,
};
pub use analysis::StatisticsUtils;

/// Operation distribution ratios for MCTS balance analysis
#[derive(Debug, Clone, Default, Serialize)]
pub struct OperationRatios {
    /// Ratio of selection operations
    pub selection_ratio: f64,
    /// Ratio of expansion operations
    pub expansion_ratio: f64,
    /// Ratio of backpropagation operations
    pub backpropagation_ratio: f64,
    /// Ratio of simulation operations
    pub simulation_ratio: f64,
}

impl OperationRatios {
    /// Create operation ratios from counter snapshot
    pub fn from_counters(snapshot: &CounterSnapshot) -> Self {
        let total_ops = snapshot.selections + snapshot.expansions + 
                       snapshot.backpropagations + snapshot.simulations;
        
        if total_ops == 0 {
            return Self::default();
        }
        
        Self {
            selection_ratio: snapshot.selections as f64 / total_ops as f64,
            expansion_ratio: snapshot.expansions as f64 / total_ops as f64,
            backpropagation_ratio: snapshot.backpropagations as f64 / total_ops as f64,
            simulation_ratio: snapshot.simulations as f64 / total_ops as f64,
        }
    }
    
    /// Check if operations are balanced for optimal MCTS performance
    pub fn is_balanced(&self) -> bool {
        // Good MCTS should have roughly equal selections, expansions, and backpropagations
        // Simulations might be higher due to batching
        let expected_ratio = 0.25; // 25% each for balanced operation
        let tolerance = 0.15; // 15% tolerance
        
        (self.selection_ratio - expected_ratio).abs() < tolerance &&
        (self.expansion_ratio - expected_ratio).abs() < tolerance &&
        (self.backpropagation_ratio - expected_ratio).abs() < tolerance
    }
    
    /// Calculate balance score (0.0 to 1.0, higher is better)
    pub fn balance_score(&self) -> f64 {
        let core_ops = [self.selection_ratio, self.expansion_ratio, self.backpropagation_ratio];
        let mean = core_ops.iter().sum::<f64>() / core_ops.len() as f64;
        
        let variance = core_ops.iter()
            .map(|&ratio| (ratio - mean).powi(2))
            .sum::<f64>() / core_ops.len() as f64;
        
        let coefficient_of_variation = if mean > 1e-10 {
            variance.sqrt() / mean
        } else {
            1.0
        };
        
        // Convert coefficient of variation to balance score
        (1.0 / (1.0 + coefficient_of_variation * 3.0)).min(1.0)
    }
    
    /// Identify the most imbalanced operation
    pub fn most_imbalanced_operation(&self) -> String {
        let expected = 0.25;
        let deviations = [
            ("selection", (self.selection_ratio - expected).abs()),
            ("expansion", (self.expansion_ratio - expected).abs()),
            ("backpropagation", (self.backpropagation_ratio - expected).abs()),
            ("simulation", (self.simulation_ratio - expected).abs()),
        ];
        
        deviations.iter()
            .max_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal))
            .map(|(name, _)| name.to_string())
            .unwrap_or_else(|| "unknown".to_string())
    }
}

// Extend CounterSnapshot with operation ratio methods
impl CounterSnapshot {
    /// Calculate operation ratios for balance analysis
    pub fn operation_ratios(&self) -> OperationRatios {
        OperationRatios::from_counters(self)
    }
    
    /// Get total operations across all counters
    pub fn total_operations(&self) -> u64 {
        self.selections + self.expansions + self.backpropagations + self.simulations
    }
    
    /// Calculate operations per node ratio
    pub fn operations_per_node(&self) -> f64 {
        if self.nodes > 0 {
            self.total_operations() as f64 / self.nodes as f64
        } else {
            0.0
        }
    }
    
    /// Calculate visits per node ratio
    pub fn visits_per_node(&self) -> f64 {
        if self.nodes > 0 {
            self.visits as f64 / self.nodes as f64
        } else {
            0.0
        }
    }
    
    /// Check if counters indicate healthy operation
    pub fn is_healthy(&self) -> bool {
        let ratios = self.operation_ratios();
        ratios.is_balanced() && self.visits_per_node() > 1.0
    }
    
    /// Get performance summary string
    pub fn performance_summary(&self) -> String {
        format!(
            "Nodes: {}, Visits: {}, Ops/Node: {:.1}, Balance: {}",
            self.nodes,
            self.visits,
            self.operations_per_node(),
            if self.operation_ratios().is_balanced() { "Good" } else { "Poor" }
        )
    }
}

/// Convenience functions for direct statistics operations
impl QuantumStatisticsCollector {
    /// Quick health check of current statistics
    pub async fn quick_health_check(
        &self,
        tree: &RwLock<HashMap<String, QuantumMCTSNode>>,
    ) -> Result<HealthStatus, CognitiveError> {
        let tree_read = tree.read().await;
        let node_count = tree_read.len();
        let total_visits = tree_read.values().map(|n| n.visits).sum::<u64>();
        drop(tree_read);
        
        let counters = self.get_counter_values();
        let ratios = counters.operation_ratios();
        
        let status = if node_count == 0 {
            HealthStatus::Initializing
        } else if !ratios.is_balanced() {
            HealthStatus::Imbalanced
        } else if total_visits < node_count as u64 {
            HealthStatus::UnderExplored
        } else {
            HealthStatus::Healthy
        };
        
        debug!("Quick health check: {:?} with {} nodes", status, node_count);
        Ok(status)
    }
    
    /// Get basic performance metrics without full statistics collection
    pub fn get_basic_metrics(&self) -> BasicMetrics {
        let counters = self.get_counter_values();
        let elapsed = self.elapsed_time().as_secs_f64();
        
        BasicMetrics {
            nodes: counters.nodes,
            visits: counters.visits,
            total_operations: counters.total_operations(),
            uptime_seconds: elapsed,
            operations_per_second: if elapsed > 0.0 {
                counters.total_operations() as f64 / elapsed
            } else {
                0.0
            },
            balance_score: counters.operation_ratios().balance_score(),
        }
    }
}

/// Health status for quick assessment
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum HealthStatus {
    Healthy,
    Initializing,
    Imbalanced,
    UnderExplored,
    Problematic,
}

impl HealthStatus {
    /// Check if status indicates acceptable health
    pub fn is_acceptable(&self) -> bool {
        matches!(self, HealthStatus::Healthy | HealthStatus::Initializing)
    }
    
    /// Get human-readable description
    pub fn description(&self) -> &'static str {
        match self {
            HealthStatus::Healthy => "System operating normally",
            HealthStatus::Initializing => "System starting up",
            HealthStatus::Imbalanced => "Operations are imbalanced",
            HealthStatus::UnderExplored => "Insufficient exploration detected",
            HealthStatus::Problematic => "System issues detected",
        }
    }
}

/// Basic metrics for lightweight monitoring
#[derive(Debug, Clone, Serialize)]
pub struct BasicMetrics {
    /// Number of nodes in tree
    pub nodes: usize,
    /// Total visits across nodes
    pub visits: u64,
    /// Total operations performed
    pub total_operations: u64,
    /// System uptime in seconds
    pub uptime_seconds: f64,
    /// Operations per second rate
    pub operations_per_second: f64,
    /// Operation balance score (0.0 to 1.0)
    pub balance_score: f64,
}

impl BasicMetrics {
    /// Get efficiency score (0.0 to 1.0)
    pub fn efficiency_score(&self) -> f64 {
        let ops_score = (self.operations_per_second / 100.0).min(1.0); // Good at 100+ ops/sec
        let balance_score = self.balance_score;
        let visit_score = if self.nodes > 0 {
            (self.visits as f64 / self.nodes as f64 / 10.0).min(1.0) // Good at 10+ visits/node
        } else {
            0.0
        };
        
        (ops_score + balance_score + visit_score) / 3.0
    }
    
    /// Check if metrics indicate good performance
    pub fn indicates_good_performance(&self) -> bool {
        self.efficiency_score() > 0.7 && self.balance_score > 0.8
    }
}

/// Factory functions for creating statistics components
pub struct StatisticsFactory;

impl StatisticsFactory {
    /// Create a new statistics coordinator with default configuration
    pub fn create_coordinator() -> StatisticsCoordinator {
        let config = QuantumMCTSConfig::default();
        StatisticsCoordinator::new(config)
    }
    
    /// Create a new statistics coordinator with custom configuration
    pub fn create_coordinator_with_config(config: QuantumMCTSConfig) -> StatisticsCoordinator {
        StatisticsCoordinator::new(config)
    }
    
    /// Create a standalone statistics collector
    pub fn create_collector(config: QuantumMCTSConfig) -> QuantumStatisticsCollector {
        QuantumStatisticsCollector::new(config)
    }
}

// Tests are kept separate in the tests/ directory as per project requirements