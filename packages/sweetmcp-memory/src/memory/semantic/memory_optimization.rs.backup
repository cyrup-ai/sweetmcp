//! Memory optimization strategies and performance enhancement
//!
//! This module provides comprehensive memory optimization with zero allocation
//! optimizations and elegant ergonomic interfaces for performance enhancement.

pub mod memory_optimization;

pub use memory_optimization::{
    OptimizationRecommendation, RecommendationType, ComplexityLevel, RiskLevel, UrgencyLevel,
    RecommendationGenerator, AnalysisResults,
    HealthCheckReport, HealthIssue, IssueSeverity, IssueCategory, HealthStatus, HealthTrend,
    PerformanceMetrics, ResourceUtilization, HealthMonitor, MonitoringThresholds,
    OptimizationExecutor, OptimizationStrategy, StrategyType, SafetyConstraints,
    ExecutionMetrics, SingleOptimizationResult, OptimizationResult,
    MemoryOptimizationCoordinator,
};

use std::collections::HashMap;
use std::time::Duration;
use tracing::debug;

use crate::utils::{Result, error::Error};
use super::{
    semantic_item::SemanticItem,
    semantic_relationship::SemanticRelationship,
    memory_manager_core::MemoryStatistics,
};

/// High-level memory optimization facade
pub struct MemoryOptimization {
    coordinator: MemoryOptimizationCoordinator,
}

impl Default for MemoryOptimization {
    fn default() -> Self {
        Self::new()
    }
}

impl MemoryOptimization {
    /// Create new memory optimization instance
    #[inline]
    pub fn new() -> Self {
        Self {
            coordinator: MemoryOptimizationCoordinator::new(),
        }
    }

    /// Create speed-optimized instance
    #[inline]
    pub fn speed_optimized() -> Self {
        Self {
            coordinator: MemoryOptimizationCoordinator::speed_optimized(),
        }
    }

    /// Create quality-optimized instance
    #[inline]
    pub fn quality_optimized() -> Self {
        Self {
            coordinator: MemoryOptimizationCoordinator::quality_optimized(),
        }
    }

    /// Create instance with custom configuration
    #[inline]
    pub fn with_config(
        recommendation_generator: RecommendationGenerator,
        optimization_strategy: OptimizationStrategy,
        monitoring_thresholds: MonitoringThresholds,
    ) -> Self {
        Self {
            coordinator: MemoryOptimizationCoordinator::with_config(
                recommendation_generator,
                optimization_strategy,
                monitoring_thresholds,
            ),
        }
    }

    /// Perform comprehensive memory optimization
    pub async fn optimize(
        &mut self,
        items: &mut HashMap<String, SemanticItem>,
        relationships: &mut HashMap<String, SemanticRelationship>,
        statistics: &MemoryStatistics,
    ) -> Result<OptimizationResult> {
        debug!("Starting memory optimization");
        self.coordinator.optimize_memory(items, relationships, statistics).await
    }

    /// Generate health check report
    pub async fn health_check(
        &self,
        items: &HashMap<String, SemanticItem>,
        relationships: &HashMap<String, SemanticRelationship>,
        statistics: &MemoryStatistics,
    ) -> Result<HealthCheckReport> {
        debug!("Generating memory health check");
        self.coordinator.generate_health_report(items, relationships, statistics).await
    }

    /// Get optimization history
    #[inline]
    pub fn get_optimization_history(&self) -> &[OptimizationResult] {
        self.coordinator.get_optimization_history()
    }

    /// Get health monitor
    #[inline]
    pub fn get_health_monitor(&self) -> &HealthMonitor {
        self.coordinator.get_health_monitor()
    }

    /// Get execution metrics
    #[inline]
    pub fn get_execution_metrics(&self) -> &ExecutionMetrics {
        self.coordinator.get_execution_metrics()
    }

    /// Update optimization strategy
    #[inline]
    pub fn update_strategy(&mut self, strategy: OptimizationStrategy) {
        self.coordinator.update_strategy(strategy);
    }

    /// Reset optimization state
    #[inline]
    pub fn reset(&mut self) {
        self.coordinator.reset();
    }
}

/// Convenience functions for quick optimization operations
impl MemoryOptimization {
    /// Quick optimization with default settings
    pub async fn quick_optimize(
        items: &mut HashMap<String, SemanticItem>,
        relationships: &mut HashMap<String, SemanticRelationship>,
        statistics: &MemoryStatistics,
    ) -> Result<OptimizationResult> {
        let mut optimizer = Self::speed_optimized();
        optimizer.optimize(items, relationships, statistics).await
    }

    /// Quality optimization with comprehensive settings
    pub async fn comprehensive_optimize(
        items: &mut HashMap<String, SemanticItem>,
        relationships: &mut HashMap<String, SemanticRelationship>,
        statistics: &MemoryStatistics,
    ) -> Result<OptimizationResult> {
        let mut optimizer = Self::quality_optimized();
        optimizer.optimize(items, relationships, statistics).await
    }

    /// Quick health check
    pub async fn quick_health_check(
        items: &HashMap<String, SemanticItem>,
        relationships: &HashMap<String, SemanticRelationship>,
        statistics: &MemoryStatistics,
    ) -> Result<HealthCheckReport> {
        let optimizer = Self::new();
        optimizer.health_check(items, relationships, statistics).await
    }
}