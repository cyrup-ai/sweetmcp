//! Memory health check and monitoring
//!
//! This module provides blazing-fast health monitoring with zero allocation
//! optimizations and elegant ergonomic interfaces for system health assessment.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::SystemTime;
use tracing::{debug, warn};

use super::optimization_recommendations::OptimizationRecommendation;

/// Health check report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheckReport {
    /// Overall health score (0.0-1.0)
    pub overall_score: f64,
    /// Individual component scores
    pub component_scores: HashMap<String, f64>,
    /// Identified issues
    pub issues: Vec<HealthIssue>,
    /// Optimization recommendations
    pub recommendations: Vec<OptimizationRecommendation>,
    /// Health trend direction
    pub trend: HealthTrend,
    /// Last check timestamp
    pub timestamp: SystemTime,
    /// Performance metrics
    pub performance_metrics: PerformanceMetrics,
    /// Resource utilization
    pub resource_utilization: ResourceUtilization,
}

impl HealthCheckReport {
    /// Create new health check report with zero allocation optimizations
    #[inline]
    pub fn new() -> Self {
        Self {
            overall_score: 0.0,
            component_scores: HashMap::new(),
            issues: Vec::new(),
            recommendations: Vec::new(),
            trend: HealthTrend::Stable,
            timestamp: SystemTime::now(),
            performance_metrics: PerformanceMetrics::default(),
            resource_utilization: ResourceUtilization::default(),
        }
    }

    /// Add component score
    #[inline]
    pub fn add_component_score(&mut self, component: String, score: f64) {
        self.component_scores.insert(component, score.clamp(0.0, 1.0));
    }

    /// Add health issue
    #[inline]
    pub fn add_issue(&mut self, issue: HealthIssue) {
        self.issues.push(issue);
    }

    /// Add recommendation
    #[inline]
    pub fn add_recommendation(&mut self, recommendation: OptimizationRecommendation) {
        self.recommendations.push(recommendation);
    }

    /// Calculate overall score from components with weighted averaging
    #[inline]
    pub fn calculate_overall_score(&mut self) {
        if self.component_scores.is_empty() {
            self.overall_score = 0.0;
            return;
        }

        // Weighted scoring based on component importance
        let weights = self.get_component_weights();
        let mut weighted_sum = 0.0;
        let mut total_weight = 0.0;

        for (component, &score) in &self.component_scores {
            let weight = weights.get(component).copied().unwrap_or(1.0);
            weighted_sum += score * weight;
            total_weight += weight;
        }

        self.overall_score = if total_weight > 0.0 {
            weighted_sum / total_weight
        } else {
            0.0
        };

        // Apply issue penalties
        let issue_penalty = self.calculate_issue_penalty();
        self.overall_score = (self.overall_score - issue_penalty).max(0.0);
    }

    /// Get component weights for scoring
    #[inline]
    fn get_component_weights(&self) -> HashMap<String, f64> {
        let mut weights = HashMap::new();
        weights.insert("memory_usage".to_string(), 2.0);
        weights.insert("cache_performance".to_string(), 1.8);
        weights.insert("index_efficiency".to_string(), 1.6);
        weights.insert("fragmentation".to_string(), 1.4);
        weights.insert("compression".to_string(), 1.2);
        weights.insert("access_patterns".to_string(), 1.0);
        weights.insert("relationship_health".to_string(), 1.3);
        weights.insert("data_integrity".to_string(), 2.0);
        weights
    }

    /// Calculate penalty from issues
    #[inline]
    fn calculate_issue_penalty(&self) -> f64 {
        let mut penalty = 0.0;
        
        for issue in &self.issues {
            penalty += match issue.severity {
                IssueSeverity::Critical => 0.3,
                IssueSeverity::High => 0.2,
                IssueSeverity::Medium => 0.1,
                IssueSeverity::Low => 0.05,
            };
        }

        penalty.min(0.8) // Cap penalty at 80%
    }

    /// Get health status
    #[inline]
    pub fn health_status(&self) -> HealthStatus {
        if self.overall_score >= 0.9 {
            HealthStatus::Excellent
        } else if self.overall_score >= 0.7 {
            HealthStatus::Good
        } else if self.overall_score >= 0.5 {
            HealthStatus::Fair
        } else if self.overall_score >= 0.3 {
            HealthStatus::Poor
        } else {
            HealthStatus::Critical
        }
    }

    /// Get high priority recommendations
    #[inline]
    pub fn high_priority_recommendations(&self) -> Vec<&OptimizationRecommendation> {
        self.recommendations.iter()
            .filter(|r| r.is_high_priority())
            .collect()
    }

    /// Get critical issues
    #[inline]
    pub fn critical_issues(&self) -> Vec<&HealthIssue> {
        self.issues.iter()
            .filter(|i| i.severity == IssueSeverity::Critical)
            .collect()
    }

    /// Get high severity issues
    #[inline]
    pub fn high_severity_issues(&self) -> Vec<&HealthIssue> {
        self.issues.iter()
            .filter(|i| matches!(i.severity, IssueSeverity::Critical | IssueSeverity::High))
            .collect()
    }

    /// Check if immediate action is required
    #[inline]
    pub fn requires_immediate_action(&self) -> bool {
        self.overall_score < 0.3 || 
        !self.critical_issues().is_empty() ||
        self.has_performance_degradation()
    }

    /// Check if performance degradation is detected
    #[inline]
    pub fn has_performance_degradation(&self) -> bool {
        self.performance_metrics.response_time_ms > 1000.0 ||
        self.performance_metrics.throughput_ops_per_sec < 100.0 ||
        self.resource_utilization.memory_usage_percent > 90.0
    }

    /// Get health summary string
    #[inline]
    pub fn get_health_summary(&self) -> String {
        format!(
            "Health: {} ({:.1}%), Issues: {} critical, {} total, Recommendations: {}",
            self.health_status().description(),
            self.overall_score * 100.0,
            self.critical_issues().len(),
            self.issues.len(),
            self.recommendations.len()
        )
    }

    /// Get detailed health report
    #[inline]
    pub fn get_detailed_report(&self) -> String {
        let mut report = String::new();
        
        report.push_str(&format!("=== Memory Health Report ===\n"));
        report.push_str(&format!("Overall Score: {:.1}% ({})\n", 
                                self.overall_score * 100.0, 
                                self.health_status().description()));
        report.push_str(&format!("Trend: {:?}\n", self.trend));
        report.push_str(&format!("Timestamp: {:?}\n\n", self.timestamp));

        // Component scores
        report.push_str("Component Scores:\n");
        for (component, score) in &self.component_scores {
            report.push_str(&format!("  {}: {:.1}%\n", component, score * 100.0));
        }

        // Performance metrics
        report.push_str(&format!("\nPerformance Metrics:\n"));
        report.push_str(&format!("  Response Time: {:.1}ms\n", self.performance_metrics.response_time_ms));
        report.push_str(&format!("  Throughput: {:.1} ops/sec\n", self.performance_metrics.throughput_ops_per_sec));
        report.push_str(&format!("  Error Rate: {:.2}%\n", self.performance_metrics.error_rate_percent));

        // Resource utilization
        report.push_str(&format!("\nResource Utilization:\n"));
        report.push_str(&format!("  Memory: {:.1}%\n", self.resource_utilization.memory_usage_percent));
        report.push_str(&format!("  CPU: {:.1}%\n", self.resource_utilization.cpu_usage_percent));
        report.push_str(&format!("  Disk I/O: {:.1}%\n", self.resource_utilization.disk_io_percent));

        // Issues
        if !self.issues.is_empty() {
            report.push_str(&format!("\nIssues ({}):\n", self.issues.len()));
            for issue in &self.issues {
                report.push_str(&format!("  [{}] {}: {}\n", 
                                        issue.severity.short_name(),
                                        issue.component,
                                        issue.description));
            }
        }

        // Recommendations
        if !self.recommendations.is_empty() {
            report.push_str(&format!("\nRecommendations ({}):\n", self.recommendations.len()));
            for rec in &self.recommendations {
                report.push_str(&format!("  [P{}] {}: {:.1}% improvement\n",
                                        rec.priority,
                                        rec.description,
                                        rec.expected_improvement));
            }
        }

        report
    }
}

impl Default for HealthCheckReport {
    fn default() -> Self {
        Self::new()
    }
}

/// Health issue
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthIssue {
    /// Issue description
    pub description: String,
    /// Severity level
    pub severity: IssueSeverity,
    /// Affected component
    pub component: String,
    /// Impact on performance (0.0-1.0)
    pub performance_impact: f64,
    /// Suggested actions
    pub suggested_actions: Vec<String>,
    /// Detection timestamp
    pub detected_at: SystemTime,
    /// Issue category
    pub category: IssueCategory,
}

impl HealthIssue {
    /// Create new health issue
    #[inline]
    pub fn new(
        description: String,
        severity: IssueSeverity,
        component: String,
        performance_impact: f64,
    ) -> Self {
        Self {
            description,
            severity,
            component: component.clone(),
            performance_impact: performance_impact.clamp(0.0, 1.0),
            suggested_actions: Vec::new(),
            detected_at: SystemTime::now(),
            category: IssueCategory::from_component(&component),
        }
    }

    /// Add suggested action
    #[inline]
    pub fn add_suggested_action(&mut self, action: String) {
        self.suggested_actions.push(action);
    }

    /// Check if issue is critical
    #[inline]
    pub fn is_critical(&self) -> bool {
        self.severity == IssueSeverity::Critical
    }

    /// Check if issue has high performance impact
    #[inline]
    pub fn has_high_performance_impact(&self) -> bool {
        self.performance_impact > 0.5
    }

    /// Get urgency score
    #[inline]
    pub fn urgency_score(&self) -> f64 {
        let severity_weight = match self.severity {
            IssueSeverity::Critical => 1.0,
            IssueSeverity::High => 0.8,
            IssueSeverity::Medium => 0.5,
            IssueSeverity::Low => 0.2,
        };

        severity_weight * self.performance_impact
    }
}

/// Issue severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum IssueSeverity {
    Critical,
    High,
    Medium,
    Low,
}

impl IssueSeverity {
    /// Get severity description
    #[inline]
    pub fn description(&self) -> &'static str {
        match self {
            IssueSeverity::Critical => "Critical - Immediate action required",
            IssueSeverity::High => "High - Action required within 24 hours",
            IssueSeverity::Medium => "Medium - Action required within a week",
            IssueSeverity::Low => "Low - Action can be scheduled",
        }
    }

    /// Get short name for display
    #[inline]
    pub fn short_name(&self) -> &'static str {
        match self {
            IssueSeverity::Critical => "CRIT",
            IssueSeverity::High => "HIGH",
            IssueSeverity::Medium => "MED",
            IssueSeverity::Low => "LOW",
        }
    }
}

/// Issue categories
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum IssueCategory {
    Memory,
    Performance,
    DataIntegrity,
    Configuration,
    Resource,
    Network,
    Unknown,
}

impl IssueCategory {
    /// Create category from component name
    #[inline]
    fn from_component(component: &str) -> Self {
        match component.to_lowercase().as_str() {
            s if s.contains("memory") => IssueCategory::Memory,
            s if s.contains("cache") || s.contains("performance") => IssueCategory::Performance,
            s if s.contains("data") || s.contains("integrity") => IssueCategory::DataIntegrity,
            s if s.contains("config") => IssueCategory::Configuration,
            s if s.contains("resource") || s.contains("cpu") || s.contains("disk") => IssueCategory::Resource,
            s if s.contains("network") => IssueCategory::Network,
            _ => IssueCategory::Unknown,
        }
    }
}

/// Health status enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    Excellent,
    Good,
    Fair,
    Poor,
    Critical,
}

impl HealthStatus {
    /// Get status description
    #[inline]
    pub fn description(&self) -> &'static str {
        match self {
            HealthStatus::Excellent => "Excellent",
            HealthStatus::Good => "Good",
            HealthStatus::Fair => "Fair",
            HealthStatus::Poor => "Poor",
            HealthStatus::Critical => "Critical",
        }
    }

    /// Get color code for display
    #[inline]
    pub fn color_code(&self) -> &'static str {
        match self {
            HealthStatus::Excellent => "green",
            HealthStatus::Good => "lightgreen",
            HealthStatus::Fair => "yellow",
            HealthStatus::Poor => "orange",
            HealthStatus::Critical => "red",
        }
    }
}

/// Health trend direction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthTrend {
    Improving,
    Stable,
    Declining,
    Unknown,
}

impl HealthTrend {
    /// Get trend description
    #[inline]
    pub fn description(&self) -> &'static str {
        match self {
            HealthTrend::Improving => "Improving",
            HealthTrend::Stable => "Stable",
            HealthTrend::Declining => "Declining",
            HealthTrend::Unknown => "Unknown",
        }
    }
}

/// Performance metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceMetrics {
    /// Average response time in milliseconds
    pub response_time_ms: f64,
    /// Throughput in operations per second
    pub throughput_ops_per_sec: f64,
    /// Error rate percentage
    pub error_rate_percent: f64,
    /// Memory allocation rate
    pub allocation_rate_mb_per_sec: f64,
    /// Garbage collection frequency
    pub gc_frequency_per_hour: f64,
}

impl Default for PerformanceMetrics {
    fn default() -> Self {
        Self {
            response_time_ms: 0.0,
            throughput_ops_per_sec: 0.0,
            error_rate_percent: 0.0,
            allocation_rate_mb_per_sec: 0.0,
            gc_frequency_per_hour: 0.0,
        }
    }
}

impl PerformanceMetrics {
    /// Check if performance is acceptable
    #[inline]
    pub fn is_performance_acceptable(&self) -> bool {
        self.response_time_ms < 500.0 &&
        self.throughput_ops_per_sec > 200.0 &&
        self.error_rate_percent < 1.0
    }

    /// Get performance score (0.0-1.0)
    #[inline]
    pub fn performance_score(&self) -> f64 {
        let response_score = (1000.0 - self.response_time_ms.min(1000.0)) / 1000.0;
        let throughput_score = (self.throughput_ops_per_sec / 1000.0).min(1.0);
        let error_score = (100.0 - self.error_rate_percent.min(100.0)) / 100.0;
        
        (response_score + throughput_score + error_score) / 3.0
    }
}

/// Resource utilization metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceUtilization {
    /// Memory usage percentage
    pub memory_usage_percent: f64,
    /// CPU usage percentage
    pub cpu_usage_percent: f64,
    /// Disk I/O usage percentage
    pub disk_io_percent: f64,
    /// Network usage percentage
    pub network_usage_percent: f64,
    /// File descriptor usage
    pub file_descriptor_usage: usize,
    /// Thread count
    pub thread_count: usize,
}

impl Default for ResourceUtilization {
    fn default() -> Self {
        Self {
            memory_usage_percent: 0.0,
            cpu_usage_percent: 0.0,
            disk_io_percent: 0.0,
            network_usage_percent: 0.0,
            file_descriptor_usage: 0,
            thread_count: 0,
        }
    }
}

impl ResourceUtilization {
    /// Check if resource usage is healthy
    #[inline]
    pub fn is_resource_usage_healthy(&self) -> bool {
        self.memory_usage_percent < 80.0 &&
        self.cpu_usage_percent < 80.0 &&
        self.disk_io_percent < 80.0
    }

    /// Get resource utilization score (0.0-1.0)
    #[inline]
    pub fn utilization_score(&self) -> f64 {
        let memory_score = (100.0 - self.memory_usage_percent.min(100.0)) / 100.0;
        let cpu_score = (100.0 - self.cpu_usage_percent.min(100.0)) / 100.0;
        let disk_score = (100.0 - self.disk_io_percent.min(100.0)) / 100.0;
        
        (memory_score + cpu_score + disk_score) / 3.0
    }

    /// Get highest usage component
    #[inline]
    pub fn highest_usage_component(&self) -> (&'static str, f64) {
        let components = [
            ("memory", self.memory_usage_percent),
            ("cpu", self.cpu_usage_percent),
            ("disk_io", self.disk_io_percent),
            ("network", self.network_usage_percent),
        ];

        components.iter()
            .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())
            .map(|&(name, usage)| (name, usage))
            .unwrap_or(("unknown", 0.0))
    }
}

/// Health monitor for continuous monitoring
pub struct HealthMonitor {
    /// Historical reports
    reports: Vec<HealthCheckReport>,
    /// Maximum history to keep
    max_history: usize,
    /// Monitoring thresholds
    thresholds: MonitoringThresholds,
}

impl Default for HealthMonitor {
    fn default() -> Self {
        Self {
            reports: Vec::new(),
            max_history: 100,
            thresholds: MonitoringThresholds::default(),
        }
    }
}

impl HealthMonitor {
    /// Create new health monitor
    #[inline]
    pub fn new(max_history: usize, thresholds: MonitoringThresholds) -> Self {
        Self {
            reports: Vec::with_capacity(max_history),
            max_history,
            thresholds,
        }
    }

    /// Add health check report
    #[inline]
    pub fn add_report(&mut self, report: HealthCheckReport) {
        self.reports.push(report);
        
        // Keep only recent history
        if self.reports.len() > self.max_history {
            self.reports.remove(0);
        }

        debug!("Added health report, total history: {}", self.reports.len());
    }

    /// Get latest report
    #[inline]
    pub fn latest_report(&self) -> Option<&HealthCheckReport> {
        self.reports.last()
    }

    /// Calculate health trend
    #[inline]
    pub fn calculate_trend(&self) -> HealthTrend {
        if self.reports.len() < 3 {
            return HealthTrend::Unknown;
        }

        let recent_scores: Vec<f64> = self.reports.iter()
            .rev()
            .take(5)
            .map(|r| r.overall_score)
            .collect();

        if recent_scores.len() < 3 {
            return HealthTrend::Unknown;
        }

        let first_half_avg = recent_scores[recent_scores.len()/2..].iter().sum::<f64>() / (recent_scores.len() - recent_scores.len()/2) as f64;
        let second_half_avg = recent_scores[..recent_scores.len()/2].iter().sum::<f64>() / (recent_scores.len()/2) as f64;

        let difference = second_half_avg - first_half_avg;

        if difference > 0.05 {
            HealthTrend::Improving
        } else if difference < -0.05 {
            HealthTrend::Declining
        } else {
            HealthTrend::Stable
        }
    }

    /// Check if alert should be triggered
    #[inline]
    pub fn should_trigger_alert(&self) -> bool {
        if let Some(latest) = self.latest_report() {
            latest.overall_score < self.thresholds.critical_score_threshold ||
            !latest.critical_issues().is_empty() ||
            latest.has_performance_degradation()
        } else {
            false
        }
    }

    /// Get alert message
    #[inline]
    pub fn get_alert_message(&self) -> Option<String> {
        if !self.should_trigger_alert() {
            return None;
        }

        if let Some(latest) = self.latest_report() {
            Some(format!(
                "HEALTH ALERT: {} - Score: {:.1}%, Critical Issues: {}, Trend: {:?}",
                latest.health_status().description(),
                latest.overall_score * 100.0,
                latest.critical_issues().len(),
                self.calculate_trend()
            ))
        } else {
            None
        }
    }
}

/// Monitoring thresholds
#[derive(Debug, Clone)]
pub struct MonitoringThresholds {
    /// Critical score threshold for alerts
    pub critical_score_threshold: f64,
    /// Warning score threshold
    pub warning_score_threshold: f64,
    /// Maximum response time before alert
    pub max_response_time_ms: f64,
    /// Minimum throughput before alert
    pub min_throughput_ops_per_sec: f64,
    /// Maximum error rate before alert
    pub max_error_rate_percent: f64,
}

impl Default for MonitoringThresholds {
    fn default() -> Self {
        Self {
            critical_score_threshold: 0.3,
            warning_score_threshold: 0.6,
            max_response_time_ms: 1000.0,
            min_throughput_ops_per_sec: 100.0,
            max_error_rate_percent: 5.0,
        }
    }
}